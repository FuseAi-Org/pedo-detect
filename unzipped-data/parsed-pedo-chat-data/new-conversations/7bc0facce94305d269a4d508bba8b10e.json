{
    "id": "7bc0facce94305d269a4d508bba8b10e",
    "messages": [
        "c480405f460f7a61964569640a6cd059 (01:00): in the product",
        "c480405f460f7a61964569640a6cd059 (01:00): how do you mean?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:00): what is the problem you want to solve by not doing a string comparison? (the url parsing having happened, as with origin checking, before having a security context)",
        "c480405f460f7a61964569640a6cd059 (01:00): the problem is in everywhere when there is a difference to url comparsing",
        "c480405f460f7a61964569640a6cd059 (01:00): which are 3 things:",
        "c480405f460f7a61964569640a6cd059 (01:01): 1. scheme in url is case insensitive",
        "c480405f460f7a61964569640a6cd059 (01:01): 2. domain in url is case insensitive",
        "c480405f460f7a61964569640a6cd059 (01:01): 3. explicit default port is same as no port",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:01): yes but the UA generates the string it is comparing to, so why does it matter? i mean, we could be generating hashes here too, why does it matter?",
        "c480405f460f7a61964569640a6cd059 (01:01): why aren't we using hashes?",
        "c480405f460f7a61964569640a6cd059 (01:02): or http.org.example.www(80)",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:02): so that the user can see what is being compared more easily",
        "c480405f460f7a61964569640a6cd059 (01:02): user won't see this",
        "c480405f460f7a61964569640a6cd059 (01:02): my mom never will",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:02): s/user/author/, sorry",
        "c480405f460f7a61964569640a6cd059 (01:03): that author will also be generating the urls for ac-allow-origin",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:03): (i'm fine with using a new syntax too, it just seems gratuitous)",
        "c480405f460f7a61964569640a6cd059 (01:03): exactly, and doing string comparison is using a new syntax",
        "c480405f460f7a61964569640a6cd059 (01:03): because we no longer treat them as urls",
        "c480405f460f7a61964569640a6cd059 (01:04): i say that if something looks like a url, we should treat it as such",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:04): and i'm saying that's a security nightmare waiting to happen",
        "c480405f460f7a61964569640a6cd059 (01:04): can you name any problems with url parsing that would have been made worse by using it for AC?",
        "c480405f460f7a61964569640a6cd059 (01:05): any problem with url parsing is already likely fatal",
        "a11aabeeceeae6b8cb5d12ea06b56554 (01:07): 69b0d3dfe919a6b860a9fac82de52a7e: Oh, just to tell him those tests that I mentioned above are broken",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:10): c480405f460f7a61964569640a6cd059: no, not off-hand. But defense in depth isn't done by making sure we don't do something that could be vulnerable to an already-fixed problem, it's done by making the attack surface smaller.",
        "c480405f460f7a61964569640a6cd059 (01:10): 69b0d3dfe919a6b860a9fac82de52a7e, it's a very gratuitous defense you are inventing",
        "c480405f460f7a61964569640a6cd059 (01:11): 69b0d3dfe919a6b860a9fac82de52a7e, if you have no idea what you are protecting yourself from, how do we know what you are inventing is better",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:11): it's simpler",
        "c480405f460f7a61964569640a6cd059 (01:11): 69b0d3dfe919a6b860a9fac82de52a7e, you are also adding risks by inventing new formats",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:11): simpler is better :-)",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:11): it's not a new format, it's a canonicalised URL",
        "c480405f460f7a61964569640a6cd059 (01:11): simpler how? for who?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:12): (s1 == s2) is simpler than (ParseURL(s1) == ParseURL(s2))",
        "c480405f460f7a61964569640a6cd059 (01:12): simpler for who?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:12): and it's simpler for authors and implementors. for authors because once they have found the string that works, it'll always work, and for implementors because, well, (s1 == s2) is simpler than (ParseURL(s1) == ParseURL(s2))",
        "c480405f460f7a61964569640a6cd059 (01:13): it's not simpler for me, it's about the same number of lines of code  (about 5 vs 8), it's not simpler for authors as they have a surprising inconsistency with all other urls in the product",
        "65325d50b2e25aca54bc871b89758c9c (01:13): as an implementor I'd say neither is particularly harder or easier",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:14): seriously? doing a security audit of the url parsing is as simple as a security audit of just comparing two strings?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:14): those must be some damn complicated string comparisong algorithms y'all are using",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:14): comparison",
        "c480405f460f7a61964569640a6cd059 (01:14): the code is already audited in both cases",
        "c480405f460f7a61964569640a6cd059 (01:15): 69b0d3dfe919a6b860a9fac82de52a7e,  i don't have two strings, i have a string (the ac-allow-origin header) and a url (the requesting site)",
        "65325d50b2e25aca54bc871b89758c9c (01:15): url parsing and comparison (and specifically of a url string converted to our SecurityOrigin class) is already audited",
        "65325d50b2e25aca54bc871b89758c9c (01:15): and already heavily exposed",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:15): c480405f460f7a61964569640a6cd059: you have two strings, the string you sent the server, and the string it sent back",
        "65325d50b2e25aca54bc871b89758c9c (01:16): I would be less nervous security-wise about a comparison of two SecurityOrigin objects than two Strings, but seems to me either could be sound",
        "c480405f460f7a61964569640a6cd059 (01:16): 69b0d3dfe919a6b860a9fac82de52a7e, i don't have the string sent to the server saved. I could save it, but it'd add about the same number of lines of code that parsing to a url adds",
        "c480405f460f7a61964569640a6cd059 (01:17): yeah, i think both these solutions are simple and both are secure. The difference is that one seems more surprising to authors",
        "65325d50b2e25aca54bc871b89758c9c (01:19): c480405f460f7a61964569640a6cd059: what's an example of a case where the author would see different behavior between the two?",
        "c480405f460f7a61964569640a6cd059 (01:19): 65325d50b2e25aca54bc871b89758c9c, HTTP://Example.Org:80   vs    http://example.org     contains all 3 differences that i can think of",
        "65325d50b2e25aca54bc871b89758c9c (01:20): c480405f460f7a61964569640a6cd059: ok, but walk me through the scenario",
        "65325d50b2e25aca54bc871b89758c9c (01:20): so let's say you loaded from a page of HTTP://Example.Org:80",
        "0da07476c4bd14079ce4032a6f280e17 (01:20): c480405f460f7a61964569640a6cd059: what about http://example.org./ vs http://example.org/",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:20): 0da07476c4bd14079ce4032a6f280e17: those are different",
        "c480405f460f7a61964569640a6cd059 (01:21): 0da07476c4bd14079ce4032a6f280e17, what hixie said",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:21): my concern is with things like http:///example.com vs http://example.com, where on UA has a bug and treats it differently than other UAs",
        "c480405f460f7a61964569640a6cd059 (01:21): 65325d50b2e25aca54bc871b89758c9c, well, the Origin header that the site is going to receive is always going to be on the &quot;canonical&quot; form (per spec)",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:22): or http:://, or http://foo.com:<email/>:81/ or whatever",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:23): seems like for something this important you shouldn't need to be a spec lawyer to be able to tell if the string is going to work or not",
        "c480405f460f7a61964569640a6cd059 (01:23): 65325d50b2e25aca54bc871b89758c9c, in most cases the server is going to have some sort of list of origins they want to approve. For example some list like      &quot;*.company.com&quot;, &quot;*.partner.com&quot;",
        "c480405f460f7a61964569640a6cd059 (01:23): 65325d50b2e25aca54bc871b89758c9c, and then match the Origin against that",
        "c480405f460f7a61964569640a6cd059 (01:24): 65325d50b2e25aca54bc871b89758c9c, and then send back a matching origin if one is found",
        "c480405f460f7a61964569640a6cd059 (01:24): 65325d50b2e25aca54bc871b89758c9c, (they're basically forced to do this given how simple the syntax of the AC-Allow-Origin header is)",
        "c480405f460f7a61964569640a6cd059 (01:25): 65325d50b2e25aca54bc871b89758c9c, so if they generate the send-back string with a uppercase Company.com because that's how they normally type the company url internally, they'll currently fail",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:25): but they'll _always_ fail, so it'll be trivial to catch",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:26): with url parsing, they might find it works in the UAs they test, but some syntax error means it fails in the rest",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:26): and they won't know until the deploy",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:26): they",
        "65325d50b2e25aca54bc871b89758c9c (01:26): c480405f460f7a61964569640a6cd059: so if you can generate the",
        "65325d50b2e25aca54bc871b89758c9c (01:27): &quot;canonical&quot; form to send it",
        "65325d50b2e25aca54bc871b89758c9c (01:27): you can generate it for the comparison too",
        "65325d50b2e25aca54bc871b89758c9c (01:27): I see the point for the send-back",
        "65325d50b2e25aca54bc871b89758c9c (01:27): requires a canonicalization on the server side, possibly",
        "c480405f460f7a61964569640a6cd059 (01:28): right",
        "c480405f460f7a61964569640a6cd059 (01:28): 69b0d3dfe919a6b860a9fac82de52a7e, differences like that are already breaking things and needs to be fixed",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:29): not necessarily",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:29): but sure, any interop issues should be fixed",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:29): my point is just that this is too important to elevate all url parsing interop issues to that level",
        "c480405f460f7a61964569640a6cd059 (01:29): i don't think this is any more important than any other place",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:30): it'd be like saying &quot;well a lot of our houses are made of wood, and wood is quite flammable, so we have to fix that anyway, it's not a reason to not build the dam using wood&quot;",
        "c480405f460f7a61964569640a6cd059 (01:30): but this is just another house, this is no more important than anything else in the browser",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:30): ?!",
        "c480405f460f7a61964569640a6cd059 (01:31): if two strings parsed into urls are considered same-origin in one UA but not in another we're already in the same trouble that would happen here",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:31): this controls the ability for any random site to transfer all my money out of my bank account",
        "65325d50b2e25aca54bc871b89758c9c (01:31): I don't think URL canonicalization is risky",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:31): it's FAR more important than, say, whether i can type a URL safely in the address bar",
        "65325d50b2e25aca54bc871b89758c9c (01:31): I think having different definitions of same-origin is more risky",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:31): i agree with maciej",
        "c480405f460f7a61964569640a6cd059 (01:31): 69b0d3dfe919a6b860a9fac82de52a7e, so does the same-origin-url-comparison code that checks if cross-frame-scripting is allowed",
        "65325d50b2e25aca54bc871b89758c9c (01:32): 69b0d3dfe919a6b860a9fac82de52a7e: the upshot of what I'm saying is that Access-Control defining same-origin differently is arguably bad",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:32): 65325d50b2e25aca54bc871b89758c9c: this isn't defining same-origin differently",
        "65325d50b2e25aca54bc871b89758c9c (01:32): since other same-origin checks canonicalize",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:33): 65325d50b2e25aca54bc871b89758c9c: it's serialising the origin, and then comparing it to someone else's attempt at doing the same thing",
        "65325d50b2e25aca54bc871b89758c9c (01:33): I guess you could see it that way",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:33): origin comparisons aren't url comparisons, they're the same thing as here, except without serialising the origin, just holding it as a tuple",
        "c480405f460f7a61964569640a6cd059 (01:33): so for what it's worth, IE does have a different concept of what is same-origin than everyone else",
        "c480405f460f7a61964569640a6cd059 (01:34): they don't consider ports to be part of the origin",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:34): (they could as easily be done by serialising, except for the unique ID case)",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:34): anyway",
        "c480405f460f7a61964569640a6cd059 (01:34): apparently they do for same-site XHR starting with IE7, but nowhere else",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:34): i'm not the editor of the AC spec, so i'm not the one you have to convince :-)",
        "c480405f460f7a61964569640a6cd059 (01:36): anne has said he'll follow what websockets do",
        "c480405f460f7a61964569640a6cd059 (01:36): though technically speaking its not up to the editor but the group as a whole",
        "c480405f460f7a61964569640a6cd059 (01:36): i'd just rather it not get to that of course",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:37): well technically it's up to Tim",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:37): but sure",
        "c480405f460f7a61964569640a6cd059 (01:37): this is far too unimportant to raise to a vote even",
        "c480405f460f7a61964569640a6cd059 (01:37): imho",
        "c480405f460f7a61964569640a6cd059 (01:37): i just don't see any advantages to the current behavior",
        "ab7faae5d7b250ea8606486575f8f79c (01:37): hsivonen: When using your HTML2XML, any spaces in attributes get turned into \\x20\\xEF\\BF\\xBD (or whatever that is in UTF-8), which seems kind of weird and undesired",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:38): c480405f460f7a61964569640a6cd059: so where do you stand on WebSocket-Location?",
        "c480405f460f7a61964569640a6cd059 (01:38): 69b0d3dfe919a6b860a9fac82de52a7e, what is that?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:39): should that be parsed and components recompared too?",
        "c480405f460f7a61964569640a6cd059 (01:39): yeah, in general i think that when we compare url like things, we should compare them as urls",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:39): cripes that makes things a lot more complicated for websocket",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:40): so should relative URLs here be resolved ?",
        "c480405f460f7a61964569640a6cd059 (01:40): i don't know anything about websockets",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:40): how should I handle IDN/punycode?",
        "c480405f460f7a61964569640a6cd059 (01:40): i was just told they had something similar as Access-Control-Allow-Origin",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:41): another reason to not do URL comparison is that we might not always be dealing with URLs, e.g. if bz gets his way and we serialise the unique ID origins too",
        "c480405f460f7a61964569640a6cd059 (01:41): so IDN is a good point actually",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:42): for WebSocket I really fear the mess that will occur if we start reparsing the output from the server",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:42): the whole point is that we want to make the handshake as hard as possible to fake",
        "c480405f460f7a61964569640a6cd059 (01:42): i don't know if www.?\u00d6.com is the same as www.?\u2022.com",
        "c480405f460f7a61964569640a6cd059 (01:42): (not sure if that comes out correct, should be uppercase a-ring vs lowercase a-ring)",
        "c480405f460f7a61964569640a6cd059 (01:43): if the web in general consider those same-origin",
        "c480405f460f7a61964569640a6cd059 (01:43): but string comparison wouldn't, that seems bad",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:43): string comparison compares the ASCII serialisation",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:43): so you would compare the punycode version",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:43): you can't send non-ASCII over HTTP",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:43): HTTP doesn't define an encoding beyond ASCII iirc",
        "c480405f460f7a61964569640a6cd059 (01:44): are the punycode of the two the same?",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:47): no idea, but that's not our problem at that point",
        "c480405f460f7a61964569640a6cd059 (01:49): well, it sort of is if string-comparison results in different behavior than url comparison",
        "69b0d3dfe919a6b860a9fac82de52a7e (01:51): how can it result in different behaviour?",
        "c480405f460f7a61964569640a6cd059 (01:51): ponders",
        "c480405f460f7a61964569640a6cd059 (01:53): so if the requesting page is www.?\u2022.com",
        "c480405f460f7a61964569640a6cd059 (01:54): actually, looks like they produce the same punycode"
    ],
    "person_ids": [
        "c480405f460f7a61964569640a6cd059",
        "69b0d3dfe919a6b860a9fac82de52a7e",
        "a11aabeeceeae6b8cb5d12ea06b56554",
        "65325d50b2e25aca54bc871b89758c9c",
        "0da07476c4bd14079ce4032a6f280e17",
        "ab7faae5d7b250ea8606486575f8f79c"
    ]
}