{
    "id": "ba4d6abad07c1c1869d5aeeddb19a1b2",
    "messages": [
        "ab7faae5d7b250ea8606486575f8f79c (18:34): heycam: That issue fails to mention that it accepts strings like &quot;nonemeet&quot; too",
        "b25b6b77a0087ff8385941e5545d32ea (18:34): http://www.ecma-international.org/news/PressReleases/PR_Ecma_finalises_major_revision_of_ECMAScript.htm",
        "438e0bbfeb945171b0ba181a7ec56cec (18:35): Hey :)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:35): Is someone from the html5lib for Python here?",
        "b25b6b77a0087ff8385941e5545d32ea (18:35): 438e0bbfeb945171b0ba181a7ec56cec: Yes",
        "438e0bbfeb945171b0ba181a7ec56cec (18:36): great :)",
        "b25b6b77a0087ff8385941e5545d32ea (18:36): &quot;TC39 members will create and test implementations of the candidate specification to verify its correctness and the feasibility of creating interoperable implementations&quot;. I wonder if they mean interoperable implemetations that can ship on the web",
        "438e0bbfeb945171b0ba181a7ec56cec (18:36): So basically I want to know",
        "438e0bbfeb945171b0ba181a7ec56cec (18:37): Do I get the lxml.html parser with this : html5lib.HTMLParser(tree=treebuilders.getTreeBuilder(&quot;lxml&quot;))?",
        "ab7faae5d7b250ea8606486575f8f79c (18:37): b25b6b77a0087ff8385941e5545d32ea: Try reading the next sentence",
        "ab7faae5d7b250ea8606486575f8f79c (18:37): &quot;The test implementations will also be used for web compatibility testing to ensure that the revised specification remains compatible with existing web applications.&quot;",
        "b25b6b77a0087ff8385941e5545d32ea (18:37): ab7faae5d7b250ea8606486575f8f79c: Oh.",
        "ab7faae5d7b250ea8606486575f8f79c (18:38): 438e0bbfeb945171b0ba181a7ec56cec: No - that uses html5lib's HTML5 parser (and constructs an lxml document from it), not lxml's non-standard HTML parser",
        "b25b6b77a0087ff8385941e5545d32ea (18:38): 438e0bbfeb945171b0ba181a7ec56cec: Yes, unless you use the latest svn in which case the best option is to use html5lib.parse(input, tree=&quot;lxml&quot;)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:39): Well",
        "438e0bbfeb945171b0ba181a7ec56cec (18:39): what now?",
        "b25b6b77a0087ff8385941e5545d32ea (18:39): Oh, sorry, I misunderstood the question",
        "b25b6b77a0087ff8385941e5545d32ea (18:39): 438e0bbfeb945171b0ba181a7ec56cec: What do you actually want to do",
        "438e0bbfeb945171b0ba181a7ec56cec (18:39): wait",
        "438e0bbfeb945171b0ba181a7ec56cec (18:39): http://paste.pocoo.org/show/ad9DwVRGDKIhXNgqSk8j/",
        "b25b6b77a0087ff8385941e5545d32ea (18:39): is not doing very well at reading at the moment",
        "438e0bbfeb945171b0ba181a7ec56cec (18:39): I want to parse my blog with the html5lib",
        "438e0bbfeb945171b0ba181a7ec56cec (18:40): and then scrape it with the resulting elementtree",
        "438e0bbfeb945171b0ba181a7ec56cec (18:40): Unfortunately I don't really find any documentation for the ElementTree except http://effbot.org/zone/pythondoc-elementtree-ElementTree.htm#elementtree.ElementTree.ElementTree-class",
        "b25b6b77a0087ff8385941e5545d32ea (18:40): 438e0bbfeb945171b0ba181a7ec56cec: That looks vaugely sensible. What is the problem?",
        "438e0bbfeb945171b0ba181a7ec56cec (18:41): http://paste.pocoo.org/show/KHOsRJHJNnHNvS9ec0Bg/ that should work",
        "438e0bbfeb945171b0ba181a7ec56cec (18:41): doesn't though",
        "b25b6b77a0087ff8385941e5545d32ea (18:41): http://codespeak.net/lxml/tutorial.html",
        "438e0bbfeb945171b0ba181a7ec56cec (18:41): http://paste.pocoo.org/show/ld7f4BUjcUZbnyFG4vGd/",
        "438e0bbfeb945171b0ba181a7ec56cec (18:41): ah...",
        "438e0bbfeb945171b0ba181a7ec56cec (18:41): the case..",
        "b25b6b77a0087ff8385941e5545d32ea (18:42): findall()?",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): yes",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): and I DO need to supply",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): an argument",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): which argument do I need to supply to find all tags?",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): .",
        "438e0bbfeb945171b0ba181a7ec56cec (18:42): ?",
        "b25b6b77a0087ff8385941e5545d32ea (18:43): if you just want all the child nodes you can just do &quot;for item in element:&quot;",
        "438e0bbfeb945171b0ba181a7ec56cec (18:43): etree.findall(&quot;.//*&quot;): that works aswell",
        "438e0bbfeb945171b0ba181a7ec56cec (18:43): thanks though b25b6b77a0087ff8385941e5545d32ea  :)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:43): Is the argument which I pass to findall called a &quot;xpath&quot;?",
        "438e0bbfeb945171b0ba181a7ec56cec (18:43): ElementPath",
        "438e0bbfeb945171b0ba181a7ec56cec (18:44): found it..",
        "438e0bbfeb945171b0ba181a7ec56cec (18:44): sorry I seem to ask only stupid questions",
        "b25b6b77a0087ff8385941e5545d32ea (18:44): 438e0bbfeb945171b0ba181a7ec56cec: If you know xpath and are using lxml you can do element.xpath(xpath_expression)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:45): Or I can just use the ElementPath?",
        "438e0bbfeb945171b0ba181a7ec56cec (18:45): http://effbot.org/zone/element-xpath.htm",
        "b25b6b77a0087ff8385941e5545d32ea (18:45): e.g. element.xpath(&quot;.//a&quot;) finds all a descendants",
        "b25b6b77a0087ff8385941e5545d32ea (18:45): 438e0bbfeb945171b0ba181a7ec56cec: ElementPaths are like a subset of XPath 1.0",
        "438e0bbfeb945171b0ba181a7ec56cec (18:46): Hrmm, I don't think I do need full xpath support, thanks for the tip though",
        "438e0bbfeb945171b0ba181a7ec56cec (18:46): b25b6b77a0087ff8385941e5545d32ea, I read on the lxml.html documentation",
        "438e0bbfeb945171b0ba181a7ec56cec (18:46): about the following function:",
        "438e0bbfeb945171b0ba181a7ec56cec (18:46): *method",
        "438e0bbfeb945171b0ba181a7ec56cec (18:46): .text_content():",
        "b25b6b77a0087ff8385941e5545d32ea (18:46): Also if you use a really up to date lxml you can probably get CSS Selectors",
        "438e0bbfeb945171b0ba181a7ec56cec (18:47): this isn't available in the lxml etree, right?",
        "b25b6b77a0087ff8385941e5545d32ea (18:47): 438e0bbfeb945171b0ba181a7ec56cec: html5lib just generates an lxml tree. It has all the features of whichever lxml you have installed",
        "438e0bbfeb945171b0ba181a7ec56cec (18:47): well, yes",
        "438e0bbfeb945171b0ba181a7ec56cec (18:47): the problem is",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): lxml.html",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): the html Etree is a special tree",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): How do I tell html5lib",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): to use the lxml.html tree?",
        "b25b6b77a0087ff8385941e5545d32ea (18:48): Oh, yeah",
        "78885357e970c69de0c33081760a04c9 (18:48): b25b6b77a0087ff8385941e5545d32ea: I don't think the .text_content() method exist in lxml.etree",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): Is there any way to use the lxml.html tree?",
        "b25b6b77a0087ff8385941e5545d32ea (18:48): So, I don't think you can at the moment because of some weirdness in the way that lxml is set up",
        "438e0bbfeb945171b0ba181a7ec56cec (18:48): I think this would be really comfortable for webscraping",
        "b25b6b77a0087ff8385941e5545d32ea (18:49): At least that is my recollection from when I implemented this stuff a while ago",
        "ab7faae5d7b250ea8606486575f8f79c (18:49): etree.tostring(node, method='text')",
        "ab7faae5d7b250ea8606486575f8f79c (18:49): might be similar to node.text_content()",
        "78885357e970c69de0c33081760a04c9 (18:49): yeah, that should be in the ballpark",
        "b25b6b77a0087ff8385941e5545d32ea (18:49): It's something like you can't create comments in lxml.html or...",
        "b25b6b77a0087ff8385941e5545d32ea (18:49): .xpath(&quot;.//text()) works",
        "b25b6b77a0087ff8385941e5545d32ea (18:50): .xpath(&quot;.//text()&quot;)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:50): thanks",
        "438e0bbfeb945171b0ba181a7ec56cec (18:50): I found in the lxml.html implementation the following",
        "438e0bbfeb945171b0ba181a7ec56cec (18:50): _collect_string_content(self)",
        "438e0bbfeb945171b0ba181a7ec56cec (18:50): should work if there is no other way",
        "438e0bbfeb945171b0ba181a7ec56cec (19:07): the .text attribute",
        "438e0bbfeb945171b0ba181a7ec56cec (19:07): works beautifully",
        "438e0bbfeb945171b0ba181a7ec56cec (19:09): ..not",
        "b25b6b77a0087ff8385941e5545d32ea (19:10): 438e0bbfeb945171b0ba181a7ec56cec: for &lt;a&gt;&lt;b&gt;foo&lt;/b&gt;bar&lt;/a&gt; a.text == None",
        "b25b6b77a0087ff8385941e5545d32ea (19:10): b.text == &quot;foo&quot;",
        "b25b6b77a0087ff8385941e5545d32ea (19:10): b.tail ==&quot;bar&quot;",
        "438e0bbfeb945171b0ba181a7ec56cec (19:11): is there any way to get the whole text and protect the formatting?",
        "438e0bbfeb945171b0ba181a7ec56cec (19:11): for example replace &lt;br&gt;",
        "438e0bbfeb945171b0ba181a7ec56cec (19:11): with \\n",
        "b25b6b77a0087ff8385941e5545d32ea (19:11): 438e0bbfeb945171b0ba181a7ec56cec: Not an easy way that I know of",
        "438e0bbfeb945171b0ba181a7ec56cec (19:11): hrm",
        "b25b6b77a0087ff8385941e5545d32ea (19:11): You would need to walk the tree, normalize whitespace and make whatever replacements you want",
        "438e0bbfeb945171b0ba181a7ec56cec (19:13): http://paste.pocoo.org/show/5gbDet52tiXSMRWkLZ4y/ ?",
        "b25b6b77a0087ff8385941e5545d32ea (19:14): That will only do children of the td",
        "438e0bbfeb945171b0ba181a7ec56cec (19:15): yes",
        "438e0bbfeb945171b0ba181a7ec56cec (19:15): that's what I want actually",
        "438e0bbfeb945171b0ba181a7ec56cec (19:16): sorry if I start to get annoying",
        "438e0bbfeb945171b0ba181a7ec56cec (19:16): but why doesn't that work: http://paste.pocoo.org/show/cfmGTUkDaWSCr1ehDH3X/ ?",
        "b25b6b77a0087ff8385941e5545d32ea (19:21): Trying to get the &quot;blockquote&quot; attribute of a &quot;blockquote&quot; element?",
        "438e0bbfeb945171b0ba181a7ec56cec (19:22): well.. kinda",
        "438e0bbfeb945171b0ba181a7ec56cec (19:22): ^^",
        "438e0bbfeb945171b0ba181a7ec56cec (19:22): It works in BeautifulSoup :D...",
        "b25b6b77a0087ff8385941e5545d32ea (19:22): Er, what does it do?",
        "b25b6b77a0087ff8385941e5545d32ea (19:22): I mean if you really have &lt;blockquote blockquote=something&gt; I guess it should work",
        "438e0bbfeb945171b0ba181a7ec56cec (19:23): it should get me the text WITHOUT markup WITH formatting out of the blockquote tags",
        "438e0bbfeb945171b0ba181a7ec56cec (19:23): &gt;IN BETWEEN HERE&lt;",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:24): with formatting without markup? how?",
        "438e0bbfeb945171b0ba181a7ec56cec (19:24): well",
        "438e0bbfeb945171b0ba181a7ec56cec (19:24): for example",
        "b25b6b77a0087ff8385941e5545d32ea (19:24): 438e0bbfeb945171b0ba181a7ec56cec: If you just want the test you can do element.xpath(&quot;.//text()&quot;)",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:24): b25b6b77a0087ff8385941e5545d32ea: You don't need XPath for that! Peh!",
        "438e0bbfeb945171b0ba181a7ec56cec (19:25): &lt;pre&gt;That's some fancy text &lt;br&gt;comment'&lt;/pre&gt;",
        "438e0bbfeb945171b0ba181a7ec56cec (19:25): Should result to",
        "b25b6b77a0087ff8385941e5545d32ea (19:25): If you want to do some formatting on the text you need to decide what formatting you want",
        "438e0bbfeb945171b0ba181a7ec56cec (19:25): That's some fancy text",
        "438e0bbfeb945171b0ba181a7ec56cec (19:25): comment",
        "438e0bbfeb945171b0ba181a7ec56cec (19:25): a11aabeeceeae6b8cb5d12ea06b56554, what should I use?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:25): b25b6b77a0087ff8385941e5545d32ea: return etree.tostring(element, encoding=unicode, method='text', with_tail=False) is better than that",
        "438e0bbfeb945171b0ba181a7ec56cec (19:26): I can't acces this function",
        "b25b6b77a0087ff8385941e5545d32ea (19:26): And implement that by e.g. walking the tree replacing &lt;br&gt; with &quot;\\n&quot; and adding the .tail of the br to the right place",
        "b25b6b77a0087ff8385941e5545d32ea (19:26): a11aabeeceeae6b8cb5d12ea06b56554: Define &quot;better&quot;",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:26): b25b6b77a0087ff8385941e5545d32ea: Quicker",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:26): b25b6b77a0087ff8385941e5545d32ea: The result is identical :P",
        "b25b6b77a0087ff8385941e5545d32ea (19:27): a11aabeeceeae6b8cb5d12ea06b56554: Seems unlikely to be a problem in this case",
        "b25b6b77a0087ff8385941e5545d32ea (19:27): It is much longer to type and easier to get wrong (maybe)",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:27): just wraps it in a function :P",
        "438e0bbfeb945171b0ba181a7ec56cec (19:27): etree doesn't got the attribute .tostring",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:27): 438e0bbfeb945171b0ba181a7ec56cec: from lxml import etree",
        "438e0bbfeb945171b0ba181a7ec56cec (19:28): I originally only wanted to import html5lib :|.."
    ],
    "person_ids": [
        "ab7faae5d7b250ea8606486575f8f79c",
        "b25b6b77a0087ff8385941e5545d32ea",
        "438e0bbfeb945171b0ba181a7ec56cec",
        "78885357e970c69de0c33081760a04c9",
        "a11aabeeceeae6b8cb5d12ea06b56554"
    ]
}