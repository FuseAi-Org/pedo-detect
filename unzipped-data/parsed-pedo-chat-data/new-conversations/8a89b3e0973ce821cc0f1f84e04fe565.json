{
    "id": "8a89b3e0973ce821cc0f1f84e04fe565",
    "messages": [
        "35e5c0a26ffbdcdab97df6c3994d9c47 (02:00): deximer: (explains the oddity that &quot;someinstance.somemethod is not someinstance.somemethod&quot; btw)",
        "d0889b0e928f2073f9876555e42fc081 (02:00): comand: what do you want to know? Whether it's callable? It might not be a method and yet still be callable. If you really want to know if its a method, you'll have to check its type() -- but that may skip things that are not the methodtype, but still are callable and *act* like methods.",
        "a80c86842668ed430e046d4ca99678fe (02:01): I only want to know if it's a method",
        "a80c86842668ed430e046d4ca99678fe (02:01): and therein is my original question :)",
        "394a2bb01d45266c3b84ed5567d9be84 (02:01): what's the shortest no-op?",
        "35e5c0a26ffbdcdab97df6c3994d9c47 (02:01): this kind of thing is quite a bit trickier than it might seem at first glance",
        "c8eef4fe46ca32f6b28a91d7abc35383 (02:01): treitter: pass",
        "a80c86842668ed430e046d4ca99678fe (02:01): type(probably_a_method) is ???",
        "394a2bb01d45266c3b84ed5567d9be84 (02:01): ldlework: thanks",
        "a80c86842668ed430e046d4ca99678fe (02:01): what can I test against?",
        "d0889b0e928f2073f9876555e42fc081 (02:01): comand: but how do *you* define 'method'? Any attribute of the object that can be called? Or something that is actually an instance method (and thus not just any attribute that can be called?)",
        "d0889b0e928f2073f9876555e42fc081 (02:01): comand: for actual instancemethods, types.MethodType",
        "f3a2b50d6a7a17ea3e0dcb7aff83ddd2 (02:01): does anyone here happen to know something about pyobjc?",
        "a80c86842668ed430e046d4ca99678fe (02:01): Yhg1s: I mean something that was explicitly def'd in the class",
        "ffb8c62f79541fe7f9973a62423f5c23 (02:01): marienz: Yes, I've seen o.m is not o.m.  What is the difference between lifting it out of the __dict__ and lifting it as an attrib of an uninstanciated class?",
        "d0889b0e928f2073f9876555e42fc081 (02:02): comand: well, classmethods and staticmethods are def'ed in the class too :)",
        "f3a2b50d6a7a17ea3e0dcb7aff83ddd2 (02:02): I want to play with it, pyobjc.sf.net has py2.4 packages but macosx ships with py2.3",
        "a80c86842668ed430e046d4ca99678fe (02:02): Yhg1s: I was using types.MethodType to test, but apparently, type(probably_a_method) returns TypeType",
        "d0889b0e928f2073f9876555e42fc081 (02:02): deximer: lifting it out of the __dict__ doesn't fire descriptors.",
        "d0889b0e928f2073f9876555e42fc081 (02:02): comand: then it isn't a method, it's a type (or class)",
        "a80c86842668ed430e046d4ca99678fe (02:03): ack, that's probably what I was doing -- checking for ClassType somewhere else",
        "ffb8c62f79541fe7f9973a62423f5c23 (02:03): Yhg1s: is this because __getattr__ of &lt;type&gt; or &lt;object&gt; does the wrapping?",
        "a80c86842668ed430e046d4ca99678fe (02:03): I don't want to get classmethod or staticmethods",
        "d0889b0e928f2073f9876555e42fc081 (02:03): deximer: no, __getattribute__ (the thing that does the actual lookup -- __getattr__ just handles nonexistant attributes.)",
        "3a5713bfa8a3f71cd64715461079cf0d (02:04): when I try to run my program that connect to some ftp and get some file first, it runs, but I must wait a few seconds before running this again, otherwise it gives me this error: <a href=\"http://deadbeefbabe.org/paste/2009\">http://deadbeefbabe.org/paste/2009</a>",
        "ffb8c62f79541fe7f9973a62423f5c23 (02:04): Yhg1s: so, to be clear,  __getattribute__ or &lt;type&gt; or &lt;object&gt; does the wrapping?",
        "ffb8c62f79541fe7f9973a62423f5c23 (02:04): s/or/of",
        "d0889b0e928f2073f9876555e42fc081 (02:04): of &lt;type&gt;, yes.",
        "35e5c0a26ffbdcdab97df6c3994d9c47 (02:05): dutche-: my guess would be the ftp server you are connecting to disconnects you if you reconnect too quickly and the ftplib is not handling that as nicely as it possibly could.",
        "ffb8c62f79541fe7f9973a62423f5c23 (02:05): Yhg1s, merienz: Thanks for humouring me, this was helpful",
        "3a5713bfa8a3f71cd64715461079cf0d (02:09): marienz, hmm sould be the server",
        "3a5713bfa8a3f71cd64715461079cf0d (02:09): marienz, thanks!",
        "a80c86842668ed430e046d4ca99678fe (02:10): Yhg1s: So, I now have a list of '&lt;bound method' objects.  I changed one method to be a @staticmethod, and antoher to be a @classmethod, and see no difference between the returned objects...",
        "a80c86842668ed430e046d4ca99678fe (02:10): should there be?",
        "d0889b0e928f2073f9876555e42fc081 (02:12): comand: a staticmethod should be a function. a classmethod is actually an instancemethod of the class (if you fetch it through the class. If you fetch it from the __dict__, the types would be 'staticmethod' and 'classmethod' respectively.)",
        "394a2bb01d45266c3b84ed5567d9be84 (02:12): Given these lines:",
        "394a2bb01d45266c3b84ed5567d9be84 (02:13): name_mtime = os.stat(os.path.join(root, name))[ST_MTIME]",
        "394a2bb01d45266c3b84ed5567d9be84 (02:13): if (name_mtime &gt; arg_time):",
        "394a2bb01d45266c3b84ed5567d9be84 (02:13): when I hit the if, printing out the values, name_mtime actuall is greater than arg_time, but it's evaluating false",
        "a80c86842668ed430e046d4ca99678fe (02:13): Yhg1s: ok, slightly less cloudy than before -- thanks :)",
        "d0889b0e928f2073f9876555e42fc081 (02:13): treitter: use '.st_mtime' instead of '[ST_MTIME]', or just use 'os.path.getmtime()'",
        "394a2bb01d45266c3b84ed5567d9be84 (02:14): Yhg1s: sounds better to me :)",
        "d0889b0e928f2073f9876555e42fc081 (02:14): treitter: howmuch greater is it?",
        "394a2bb01d45266c3b84ed5567d9be84 (02:14): Yhg1s: any idea why that would matter?",
        "394a2bb01d45266c3b84ed5567d9be84 (02:14): Yhg1s: it's    name_mtime: 1159304599    and    arg_time:   1159303626",
        "394a2bb01d45266c3b84ed5567d9be84 (02:14): so it's less than 1 thousand greater",
        "d0889b0e928f2073f9876555e42fc081 (02:15): treitter: and are you printing the repr() of both, or just the values?",
        "d0889b0e928f2073f9876555e42fc081 (02:15): treitter: I suspect arg_time is actually a string (but you won't be able to tell unless you repr())",
        "394a2bb01d45266c3b84ed5567d9be84 (02:15): Yhg1s: interesting. Let me check that out",
        "394a2bb01d45266c3b84ed5567d9be84 (02:15): I'm just passing them to print",
        "394a2bb01d45266c3b84ed5567d9be84 (02:16): ah",
        "394a2bb01d45266c3b84ed5567d9be84 (02:16): and print didn't complain about not casting",
        "d0889b0e928f2073f9876555e42fc081 (02:16): treitter: when debugging, always use repr().",
        "394a2bb01d45266c3b84ed5567d9be84 (02:17): Yhg1s: thanks!",
        "394a2bb01d45266c3b84ed5567d9be84 (02:17): Yhg1s: yeah - arg_time is directly from sys.argv[], so I forgot to cast it",
        "394a2bb01d45266c3b84ed5567d9be84 (02:17): er",
        "394a2bb01d45266c3b84ed5567d9be84 (02:17): convert"
    ],
    "person_ids": [
        "35e5c0a26ffbdcdab97df6c3994d9c47",
        "d0889b0e928f2073f9876555e42fc081",
        "a80c86842668ed430e046d4ca99678fe",
        "394a2bb01d45266c3b84ed5567d9be84",
        "c8eef4fe46ca32f6b28a91d7abc35383",
        "f3a2b50d6a7a17ea3e0dcb7aff83ddd2",
        "ffb8c62f79541fe7f9973a62423f5c23",
        "3a5713bfa8a3f71cd64715461079cf0d"
    ]
}