{
    "id": "0fb3b9fec50724f2845d337655a367ac",
    "messages": [
        "b8810fee2f4a71f849f3f7409546d1d9 (15:28): looks like ISSUEs are as important as ever http://www.w3.org/html/wg/tracker/issues/170",
        "b8810fee2f4a71f849f3f7409546d1d9 (15:38): looking at the number of duplicates on https://bugzilla.mozilla.org/show_bug.cgi?id=162653 I wonder if mattur will be able to find an XML design thread from 1997 or 1998 containing an assertion that HTML authors won't be confused by XML doing &lt;foo/&gt;",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:49): Is (char)(int)1 a plausible way to check endianness of integers",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:49): ?",
        "b25b6b77a0087ff8385941e5545d32ea (15:52): a11aabeeceeae6b8cb5d12ea06b56554: Won't the compiler get upset by that?",
        "b25b6b77a0087ff8385941e5545d32ea (15:52): See also http://stackoverflow.com/questions/1001307/detecting-endianness-programmatically-in-a-c-program",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:52): (Yay for writing code that depends on endianness)",
        "ab7faae5d7b250ea8606486575f8f79c (15:56): int i = 1; char c[sizeof(int)]; memcpy(c, &amp;i, sizeof(int)); bool is_littleendian = c[0];",
        "ab7faae5d7b250ea8606486575f8f79c (15:57): I'm not sure the union trick is actually legal C (though I'm not sure it's illegal either)",
        "ab7faae5d7b250ea8606486575f8f79c (15:57): but memcpy is always safe",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:58): ab7faae5d7b250ea8606486575f8f79c: It's illegal, I'm pretty certain. At least people have managed to cite quite obvious bits of the spec about it.",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:58): (Well, it's not illgal, it's just undefined.)",
        "ab7faae5d7b250ea8606486575f8f79c (15:58): (char)(int)1 will always just give you 1, and *(char*)&amp;i will give you bogus results depending on what compiler version and optimisation settings you use",
        "ab7faae5d7b250ea8606486575f8f79c (16:00): (The union thing works in all compilers in practice, though)",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:00): ab7faae5d7b250ea8606486575f8f79c: Casting to char always take the low-bits?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:01): ab7faae5d7b250ea8606486575f8f79c: bool is C99?",
        "b25b6b77a0087ff8385941e5545d32ea (16:02): would imageine without knowing that casting to char does an actual type conversion rather than just reading some subset of the bits",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:02): b25b6b77a0087ff8385941e5545d32ea: What else can it do?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:03): b25b6b77a0087ff8385941e5545d32ea: a char is just a numberic type",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:03): *numeric",
        "b25b6b77a0087ff8385941e5545d32ea (16:03): Well yes, I know that",
        "b25b6b77a0087ff8385941e5545d32ea (16:03): It could overflow differently, for example. And be endianness independent.",
        "ab7faae5d7b250ea8606486575f8f79c (16:04): If char is unsigned, then (char)i adds or subtracts 256 to/from i until it's in the range [0, 255] and then returns that",
        "ab7faae5d7b250ea8606486575f8f79c (16:04): If char is signed, and i is in [0, 255] then it returns that, else it's implementation-defined behaviour",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:04): ab7faae5d7b250ea8606486575f8f79c: I could remember there was some magic about char, but I couldn't remember what.",
        "ab7faae5d7b250ea8606486575f8f79c (16:05): The magic thing is that you don't know whether it's signed or unsigned",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:05): And about casting as well? Which I guess is the adding/subtracting\u201a\u00c4\u00b6",
        "ab7faae5d7b250ea8606486575f8f79c (16:06): (bool isn't in C99; use a BOOL or int or whatever, or use C++)",
        "ab7faae5d7b250ea8606486575f8f79c (16:07): In C99, casting is the same process for any integer types (except _Bool)",
        "ab7faae5d7b250ea8606486575f8f79c (16:07): ...except replace &quot;256&quot; by appropriate values etc",
        "3034eba67524e531235cc43f04d4f88c (16:08): according to http://en.wikipedia.org/wiki/Stdbool.h , bool expands to _Bool in C99",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:08): ab7faae5d7b250ea8606486575f8f79c: (Yeah, I know what to do)",
        "ab7faae5d7b250ea8606486575f8f79c (16:09): Basically it always does the mathematically obvious thing, except it's unwilling to assume two's-complement representation so any cases of signed overflow are implementation-defined behaviour",
        "ab7faae5d7b250ea8606486575f8f79c (16:10): and it's all endian-independent until you try to read the char representation of a larger value",
        "ab7faae5d7b250ea8606486575f8f79c (16:11): But in any case, it's usually more useful to know endianness at compile-time and not run-time",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:12): so reading an int into a short is endian dependent, assuming they're different sizes?",
        "ab7faae5d7b250ea8606486575f8f79c (16:12): since then you can have byte-swap macros that get replaced with noops",
        "ab7faae5d7b250ea8606486575f8f79c (16:12): so you should have a configure script or something to detect it and set a macro",
        "ab7faae5d7b250ea8606486575f8f79c (16:12): What do you mean by &quot;reading into&quot;?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:13): *read the short representation of an int",
        "ab7faae5d7b250ea8606486575f8f79c (16:16): What do you mean by that?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:16): ab7faae5d7b250ea8606486575f8f79c: (But yes, it makes sense to do this in a saner way once I have all the setup to do that, which is pretty much going to be when I stop playing around with this code as a standalone application",
        "ab7faae5d7b250ea8606486575f8f79c (16:16): (Values have byte repesentations, not short representations)",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:17): wants to give up on IRC as this internet connection isn't working well",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:17): is on the WCML being all fancy and stuff in first-class, because Bank Holiday Monday =&gt; cheap upgrades.",
        "ab7faae5d7b250ea8606486575f8f79c (16:24): In practice, the solution that works 99.99% of the time is &quot;#define IS_LITTLE_ENDIAN 1&quot;",
        "a11aabeeceeae6b8cb5d12ea06b56554 (16:26): That's effectively what this code already is. :)",
        "1f58faf0d058f303f30239a369808167 (16:40): http://glandium.org/blog/?p=2180",
        "efcfdc75e9299f9082b85c6f181b106f (16:41): About the article tag ... why is it the author's responsability to decide what content is syndicable?",
        "efcfdc75e9299f9082b85c6f181b106f (16:45): Or is the &quot;syndication&quot; part just a way of helping you decide whether to use an article tag?"
    ],
    "person_ids": [
        "b8810fee2f4a71f849f3f7409546d1d9",
        "a11aabeeceeae6b8cb5d12ea06b56554",
        "b25b6b77a0087ff8385941e5545d32ea",
        "ab7faae5d7b250ea8606486575f8f79c",
        "3034eba67524e531235cc43f04d4f88c",
        "1f58faf0d058f303f30239a369808167",
        "efcfdc75e9299f9082b85c6f181b106f"
    ]
}