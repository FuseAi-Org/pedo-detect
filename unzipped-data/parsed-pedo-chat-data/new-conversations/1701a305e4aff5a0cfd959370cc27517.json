{
    "id": "1701a305e4aff5a0cfd959370cc27517",
    "messages": [
        "042dd99eb0ff8653814e445ca0093427 (05:03): 1f8387eb43f131d7c309a90a4e36b5cb: the group depends on how you want to do this",
        "042dd99eb0ff8653814e445ca0093427 (05:04): you should ask your &quot;friend&quot; if they can get by with hand-subsetted fonts and unicode-range",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:05): 042dd99eb0ff8653814e445ca0093427: The idea is to pursue this as a line of experimentation for Chrome, so apparently the answer is no.  ^_^",
        "042dd99eb0ff8653814e445ca0093427 (05:06): It may be over-generous to assume that existing APIs have been fully explored",
        "042dd99eb0ff8653814e445ca0093427 (05:07): we seem to frequently get feature requests where that is not the case",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:08): I know that in my chatting with the dude, he explicitly talks about why subsetting is unsatisfactory.",
        "042dd99eb0ff8653814e445ca0093427 (05:08): What is it?",
        "042dd99eb0ff8653814e445ca0093427 (05:09): anyway, the point stands: if you have a proposal, you can figure out what group(s) it should go to, but if you only have a problem statement, it's unclear",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:09): Because you have to subset separately for every page if you want maximum efficiency, and monitor page changes so you know if you need to rengerate yoru subsets.",
        "042dd99eb0ff8653814e445ca0093427 (05:09): that's not what I'm saying",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:09): I have a problem statement.",
        "042dd99eb0ff8653814e445ca0093427 (05:09): because what I said was totally unclear",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:09): Heh.",
        "042dd99eb0ff8653814e445ca0093427 (05:10): How about this: split your font into a number of different fonts, each covering some range of Unicode characters",
        "042dd99eb0ff8653814e445ca0093427 (05:10): then apply all those fonts to the page with CSS 'unicode-range'",
        "042dd99eb0ff8653814e445ca0093427 (05:10): A browser implementation should automatically load the subset-font(s) that are needed",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:11): Interesting.  Didn't realize we should do that.",
        "042dd99eb0ff8653814e445ca0093427 (05:11): even if an implementation currently doesn't, it could",
        "042dd99eb0ff8653814e445ca0093427 (05:12): I can believe that approach doesn't work well; maybe there is no adequate choice for the granularity of the subset fonts",
        "042dd99eb0ff8653814e445ca0093427 (05:12): but I hope it's been tried",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:12): I don't know if it has.",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:12): Bringing it up now.",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:13): (In email, so asynchronous.)",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:13): In unrelated news, 042dd99eb0ff8653814e445ca0093427, I had a question for you about http://weblogs.mozillazine.org 042dd99eb0ff8653814e445ca0093427/archives/2008/07/svg_paint_serve.html",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:13): I don't understand the distinction you're drawing between the coordinate spaces there.",
        "042dd99eb0ff8653814e445ca0093427 (05:15): if that doesn't work well, an alternative to consider would be to see if it's possible to lay out OpenType fonts cleverly and use byte-range requests to load desired subsets; again, no new API would be needed",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:16): Yeah, that's something we wanted to broach somewhere.",
        "042dd99eb0ff8653814e445ca0093427 (05:17): possibly you don't have to broach it anywhere",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:17): Broach = raise in hearing of someone who knows what they're doing, so we know if it's possible.",
        "042dd99eb0ff8653814e445ca0093427 (05:17): just start loading the font file, once you have sufficient headers, spin up a parallel load with byte-range requests for the data you want to get quicker",
        "042dd99eb0ff8653814e445ca0093427 (05:19): 1f8387eb43f131d7c309a90a4e36b5cb: I think those coordinate spaces are effectively the same; I just defined them differently because they get used differently in SVG",
        "042dd99eb0ff8653814e445ca0093427 (05:20): for example, if your element is 20px wide, then with userSpaceOnUse a width value of &quot;1&quot; is 1px, but with objectBoundingBox a width value of &quot;1&quot; would be 20px",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:21): Hmm.",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:21): Does that latter one actually do something useful?",
        "042dd99eb0ff8653814e445ca0093427 (05:22): that is how objectBoundingBox coordinates work in SVG",
        "042dd99eb0ff8653814e445ca0093427 (05:23): 0,0 is the top-left of the &quot;object bounding box&quot;, 1,1 is the bottom right",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:23): Oh, ok.  I don't ever use that coordinate space, obviously.",
        "042dd99eb0ff8653814e445ca0093427 (05:23): it's quite stupid, but that's how it works",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:24): I was wanting to specify this behavior in Image Values, and I was scratching my head at it at first.",
        "1f8387eb43f131d7c309a90a4e36b5cb (05:25): Your definition of userSpaceOnUse is actually very useful for the eventual unification of &lt;image&gt; and paint servers that I'd like to do."
    ],
    "person_ids": [
        "042dd99eb0ff8653814e445ca0093427",
        "1f8387eb43f131d7c309a90a4e36b5cb"
    ]
}