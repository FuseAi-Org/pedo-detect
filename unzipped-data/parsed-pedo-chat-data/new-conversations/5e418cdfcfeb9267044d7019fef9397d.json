{
    "id": "5e418cdfcfeb9267044d7019fef9397d",
    "messages": [
        "657d76e710580c54a95963dd10f4f334 (02:28): Is there a property or method to set the mouse hover color of a ToolStripMenuItem object?",
        "657d76e710580c54a95963dd10f4f334 (02:30): It looks like what i want is the RenderMode but cant see a way to change color",
        "657d76e710580c54a95963dd10f4f334 (02:31): Oh. My mistake. MenuStrip...",
        "7a1c39ff67086cf06794141fff1388d0 (02:34): with an XmlNodeReader, how can I just get all the children as a string??",
        "7a1c39ff67086cf06794141fff1388d0 (02:35): for example, if the children are &lt;foo&gt;stuff&lt;/foo&gt;&lt;foo&gt;other&lt;/foo&gt;, I just want that XML as the string",
        "839bc7ed2771b6f3310f45a914979e59 (02:50): hi, does it matter if I do a managed library in C# other than c++/cli for unmanged c/c++",
        "4eebb990e98982ce6579a9c1b716e44d (02:51): ?",
        "4eebb990e98982ce6579a9c1b716e44d (02:51): I don't understand that question",
        "69e2e9b6faa43ce63a2ecee941ecc641 (02:51): you should just be able to ref the DLL",
        "69e2e9b6faa43ce63a2ecee941ecc641 (02:51): and use it normally",
        "839bc7ed2771b6f3310f45a914979e59 (02:51): i mean in terms of speed",
        "839bc7ed2771b6f3310f45a914979e59 (02:52): if we construct the managed wrapper using c# or using c++/cli",
        "9351c00f73660c0a9076d185506e355f (02:52): c++/cli is a managed code",
        "839bc7ed2771b6f3310f45a914979e59 (02:52): i know",
        "9351c00f73660c0a9076d185506e355f (02:52): so it wont make a difference",
        "839bc7ed2771b6f3310f45a914979e59 (02:52): it all compiles to the same thing",
        "9351c00f73660c0a9076d185506e355f (02:52): but if you compile library into native code, then make a wapper, you might gain speed if the library will be doing much stuff",
        "9351c00f73660c0a9076d185506e355f (02:53): eg. perfom very costly calculaations, that take a second in c/c++, but take few seconds in c#",
        "9351c00f73660c0a9076d185506e355f (02:53): s/c#/managed code/",
        "9351c00f73660c0a9076d185506e355f (02:54): this way, the overhead produced by wrapper will be zero when compared to the time of calculation",
        "839bc7ed2771b6f3310f45a914979e59 (02:54): but it is the EXACT same thing if I do a wrapper in C++/CLI and C#",
        "839bc7ed2771b6f3310f45a914979e59 (02:54): they will produce the exact same dll..",
        "9351c00f73660c0a9076d185506e355f (02:54): wrapper of what? unmanaged code?",
        "839bc7ed2771b6f3310f45a914979e59 (02:54): no speed difference",
        "839bc7ed2771b6f3310f45a914979e59 (02:54): yes",
        "9351c00f73660c0a9076d185506e355f (02:54): no difference",
        "839bc7ed2771b6f3310f45a914979e59 (02:54): okay cool",
        "9351c00f73660c0a9076d185506e355f (02:54): even when you do it in VB.NET",
        "9351c00f73660c0a9076d185506e355f (02:55): c++/cli, vb.net, c# are compiled into the same bytecode",
        "4eebb990e98982ce6579a9c1b716e44d (02:55): well, virutally the same",
        "9351c00f73660c0a9076d185506e355f (02:56): sabiancrash: more or less, but that should not judge on th efficency but ratheron the programmer who wrote the code",
        "839bc7ed2771b6f3310f45a914979e59 (02:56): <a href=\"http://www.gotdotnet.com/team/cplusplus/articles/mcmigrate.doc\">http://www.gotdotnet.com/team/cplusplus/articles/mcmigrate.doc</a>",
        "839bc7ed2771b6f3310f45a914979e59 (02:56): yuo",
        "4eebb990e98982ce6579a9c1b716e44d (02:57): Well, there still could be differences in the csc versus the vbc versus the ...",
        "9351c00f73660c0a9076d185506e355f (02:57): once i've been writing wrapper to mimetic (mime library), it was hell",
        "4eebb990e98982ce6579a9c1b716e44d (02:57): whatever differences are likely to be minor",
        "9351c00f73660c0a9076d185506e355f (02:58): sabiancrash: just as i said, if the library does all the calculations, there should be no difference",
        "9351c00f73660c0a9076d185506e355f (02:58): sabiancrash: no visible difference :)",
        "9351c00f73660c0a9076d185506e355f (02:59): `m0: dont even thing about porting types from the lib, into the managed code",
        "9351c00f73660c0a9076d185506e355f (03:00): `m0: what i did was, i've extended library with few 'do some magic functions', which just did all the magic and returned me result in some struct, wich i had to mangle inside c# code",
        "06d9f5004faf7205aca782823f1c53be (03:00): also let it be known that native compiled libraries can have a DISADVANTAGE of being.... NATIVE..... processors change, so do compiler optimizations, so what may be fastest now for a set of instructions could be faster a different way in 3 years...",
        "9351c00f73660c0a9076d185506e355f (03:01): GoatCheez: no?",
        "06d9f5004faf7205aca782823f1c53be (03:01): no what",
        "9351c00f73660c0a9076d185506e355f (03:01): GoatCheez: you still need other os in order to use optimized stuff",
        "06d9f5004faf7205aca782823f1c53be (03:01): the JITr could optimize the code better in the future is what i'm saying",
        "9351c00f73660c0a9076d185506e355f (03:02): no?",
        "06d9f5004faf7205aca782823f1c53be (03:02): the native dll won't change",
        "06d9f5004faf7205aca782823f1c53be (03:02): the instructions are &quot;in stone&quot;",
        "06d9f5004faf7205aca782823f1c53be (03:02): (cpu instructions)",
        "9351c00f73660c0a9076d185506e355f (03:02): JIT in 5 years will be running slower on cpu from the future than the native code",
        "9351c00f73660c0a9076d185506e355f (03:02): that was produced now",
        "06d9f5004faf7205aca782823f1c53be (03:02): not true",
        "06d9f5004faf7205aca782823f1c53be (03:02): i'd bet $100",
        "9351c00f73660c0a9076d185506e355f (03:02): ok, we have a bet ;)",
        "e977bc5a5e4f09f2aeb7b823aabe6da5 (03:02): is there some class in .NET that has all the window message constants??",
        "9351c00f73660c0a9076d185506e355f (03:03): see you in 5 years",
        "06d9f5004faf7205aca782823f1c53be (03:03): JIT stuff NOW runs faster than native stuff compiled 5 years ago",
        "06d9f5004faf7205aca782823f1c53be (03:03): eh, 7-8 years ago i should say",
        "06d9f5004faf7205aca782823f1c53be (03:03): 5 years is too close",
        "9351c00f73660c0a9076d185506e355f (03:03): GoatCheez: somehow i dont belive you ;)",
        "9351c00f73660c0a9076d185506e355f (03:03): make that times of 386 and i will be live you",
        "9351c00f73660c0a9076d185506e355f (03:04): *belive*",
        "9351c00f73660c0a9076d185506e355f (03:04): GoatCheez: current trend of extending cpu power does into adding new cores",
        "06d9f5004faf7205aca782823f1c53be (03:04): well, take something optimized for the p6 architecture, and it won't run as efficiently on the last p4 architecture... i forgot the name... i wanna say netburst, but i'm afraid that's the name of the core duo arch",
        "9351c00f73660c0a9076d185506e355f (03:04): GoatCheez: if your app is single thread, nothing will change",
        "06d9f5004faf7205aca782823f1c53be (03:05): old p4s had like a 96 stage pipeline",
        "06d9f5004faf7205aca782823f1c53be (03:05): p6's were like 28",
        "06d9f5004faf7205aca782823f1c53be (03:05): the branch prediction on those p4s was DRASTICLY different",
        "06d9f5004faf7205aca782823f1c53be (03:05): than ANYTHING ELSE",
        "9351c00f73660c0a9076d185506e355f (03:05): branch prediction is not done in the assembler",
        "9351c00f73660c0a9076d185506e355f (03:06): its done by the cpu",
        "06d9f5004faf7205aca782823f1c53be (03:06): you can optimize the assembly generated to prevent more misses",
        "9351c00f73660c0a9076d185506e355f (03:06): some cpus had soemthing like the instructions to tell which jump is more probable, but nobody usesi t nowadays",
        "06d9f5004faf7205aca782823f1c53be (03:06): which are costly",
        "9351c00f73660c0a9076d185506e355f (03:06): s/is/are",
        "06d9f5004faf7205aca782823f1c53be (03:06): i really don't doubt that GCC would use those",
        "06d9f5004faf7205aca782823f1c53be (03:07): or at least tried to at some point",
        "9351c00f73660c0a9076d185506e355f (03:07): theer are not any",
        "06d9f5004faf7205aca782823f1c53be (03:07): you just said there were",
        "9351c00f73660c0a9076d185506e355f (03:07): modern cpus dont use predefined branch predictions",
        "9351c00f73660c0a9076d185506e355f (03:07): they just were for testing",
        "9351c00f73660c0a9076d185506e355f (03:07): havn;t you heard abotu cpus that never came to stock?",
        "06d9f5004faf7205aca782823f1c53be (03:08): not much if ever....",
        "9351c00f73660c0a9076d185506e355f (03:08): there was some series of intel cpus with that shit",
        "9351c00f73660c0a9076d185506e355f (03:08): it never was released",
        "06d9f5004faf7205aca782823f1c53be (03:08): if i do hear i tend to forget most of it since it won't matter in the future... i would take maybe a lesson learned from an article written about said cpu, but i wouldn't remember the name or specs much",
        "9351c00f73660c0a9076d185506e355f (03:09): coz the dynamic prediction (far more complex than 2 stare, or 4 state prediction), was handling that better than the compile time prediction",
        "9351c00f73660c0a9076d185506e355f (03:10): 2 years ago i had computer architecture classes, i've gone trough all possible intel cpus",
        "9351c00f73660c0a9076d185506e355f (03:10): some had nice ideas, but they didnt work ;D",
        "06d9f5004faf7205aca782823f1c53be (03:10): bah d00d. you are missing the point... the compiler can optimize code to prevent the misses of dynamic prediction even!!!!@",
        "8768516d0d5cc75769ca93adefdd94b5 (03:11): GoatCheez  GCC does use the branch-predictor.",
        "8768516d0d5cc75769ca93adefdd94b5 (03:11): You compile it once with some wierd flag, run it, and it spits out a file from your use of it.  You then feed that file into the compiler, and recompile with a diffrent flag, and it'll use that prediction.",
        "9351c00f73660c0a9076d185506e355f (03:12): GoatCheez: the onl;y difference in speed i;ve noticed what the speed difference between code compiled to i486 and pentium",
        "06d9f5004faf7205aca782823f1c53be (03:12): Kunnis: exactly",
        "5022cf57fb9482c659ea223f7e36b50d (03:12): is Dossy the primary guy hacking on AOLserver?",
        "06d9f5004faf7205aca782823f1c53be (03:12): pks: which is almost exactly what i'm talking about",
        "9351c00f73660c0a9076d185506e355f (03:12): GoatCheez: it was like 2 time faster for penmtium, due to the fact that it has 2 aritmetical units, and 486 has only one",
        "8768516d0d5cc75769ca93adefdd94b5 (03:12): pks  Yeah, i586 has a lot more instructions then i486",
        "06d9f5004faf7205aca782823f1c53be (03:13): it's not JUST branch prediction that'd make JIT'd code faster on new architectures in 5-8 years"
    ],
    "person_ids": [
        "657d76e710580c54a95963dd10f4f334",
        "7a1c39ff67086cf06794141fff1388d0",
        "839bc7ed2771b6f3310f45a914979e59",
        "4eebb990e98982ce6579a9c1b716e44d",
        "69e2e9b6faa43ce63a2ecee941ecc641",
        "9351c00f73660c0a9076d185506e355f",
        "06d9f5004faf7205aca782823f1c53be",
        "e977bc5a5e4f09f2aeb7b823aabe6da5",
        "8768516d0d5cc75769ca93adefdd94b5",
        "5022cf57fb9482c659ea223f7e36b50d"
    ]
}