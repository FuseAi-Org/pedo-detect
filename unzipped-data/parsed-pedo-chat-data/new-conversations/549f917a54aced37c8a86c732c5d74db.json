{
    "id": "549f917a54aced37c8a86c732c5d74db",
    "messages": [
        "1f8387eb43f131d7c309a90a4e36b5cb (21:54): Quick question: In C, do variable names and function names live in separate namespaces?  (Unrelated to current namespace-related discussion. ^_^)",
        "e0563cc2e83070e74ce7019226dd654d (21:55): hola",
        "ab7faae5d7b250ea8606486575f8f79c (21:55): 1f8387eb43f131d7c309a90a4e36b5cb: No",
        "ab7faae5d7b250ea8606486575f8f79c (21:56): 1f8387eb43f131d7c309a90a4e36b5cb: or yes",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:56): Hrm.  So I can't have a function named &quot;add&quot; and a variable named &quot;add&quot;?",
        "ab7faae5d7b250ea8606486575f8f79c (21:56): You can have a global function called &quot;add&quot; and a local variable called &quot;add&quot; (which will shadow the function)",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:56): Damns, I thought they were separate.  Kk.",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:57): How does that not cause problems?  ::boggles::",
        "ab7faae5d7b250ea8606486575f8f79c (21:57): The syntax lets you write stuff like &amp;add which will apply to both functions and variables",
        "e0563cc2e83070e74ce7019226dd654d (21:57): can someone please explain the functionality http://dev.w3.org/html5/spec/Overview.html#ping",
        "ab7faae5d7b250ea8606486575f8f79c (21:58): 1f8387eb43f131d7c309a90a4e36b5cb: Why would it cause problems?",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:58): e0563cc2e83070e74ce7019226dd654d: If a user clicks on a link with @ping, the UA will do a normal navigation to whatever the @href is, but it will *also* fire off GET requests to all the urls in @ping.",
        "ab7faae5d7b250ea8606486575f8f79c (21:58): If you have a function and say &quot;int add = 2;&quot; then 'add' (in that scope) will refer to that variable, regardless of what's defined in global scope, which seems quite sensible",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:59): ab7faae5d7b250ea8606486575f8f79c: Well, you basically have a big set of global variables you have to manage, and be careful not to shadow.",
        "1f8387eb43f131d7c309a90a4e36b5cb (21:59): Because then you can't go &quot;add(add,3)&quot;",
        "ab7faae5d7b250ea8606486575f8f79c (21:59): POST, not GET",
        "ab7faae5d7b250ea8606486575f8f79c (21:59): (for ping)",
        "ab7faae5d7b250ea8606486575f8f79c (21:59): 1f8387eb43f131d7c309a90a4e36b5cb: You can just rename the local variable in that case",
        "ab7faae5d7b250ea8606486575f8f79c (22:00): (C++ lets you write ::add to refer to the global scope, but that's ugly)",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:01): ab7faae5d7b250ea8606486575f8f79c: Maybe the C-likes don't have the same problems with names that Lisps do.  We name a lot of functions with words that also are useful as argument names.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:01): Like the word &quot;list&quot;, which shadows the &quot;list&quot; function in Scheme.  (In CL it doens't shadow, because they live in different namespaces.)",
        "e0563cc2e83070e74ce7019226dd654d (22:01): 1f8387eb43f131d7c309a90a4e36b5cb: so @ping provides a method to multi-submit the corresponding node?",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:02): e0563cc2e83070e74ce7019226dd654d: If &quot;node&quot; means what I assume it does, then yes?",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:02): It's meant to allow you to, frex, track how often a particular link is clicked.",
        "ab7faae5d7b250ea8606486575f8f79c (22:02): 1f8387eb43f131d7c309a90a4e36b5cb: C-like languages don't have the problem of dynamic scoping, which makes it more easily manageable",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:03): Lexical, you mean.  C-likes *do* use dynamic scoping.  ^_^",
        "ab7faae5d7b250ea8606486575f8f79c (22:03): 1f8387eb43f131d7c309a90a4e36b5cb: I think you've got it precisely the wrong way round",
        "e0563cc2e83070e74ce7019226dd654d (22:03): so not necessarily multi-submit the node for processing, but submit the node to @href for processing and @ping for &quot;tracking&quot; purposes?",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:04): e0563cc2e83070e74ce7019226dd654d: Yes.",
        "e0563cc2e83070e74ce7019226dd654d (22:04): ok, thx",
        "ab7faae5d7b250ea8606486575f8f79c (22:04): There's nothing dynamic about scoping in C, it's just based on the nesting in the syntax, hence being lexical scoping",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:05): ab7faae5d7b250ea8606486575f8f79c: No, you've got it wrong way round.  Lexical scoping is what allows closures - you resolve free variables based on what's present at the time the function is defined.  Dynamic means you resolve based on what's present at call-time.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:06): http://en.wikipedia.org/wiki/Scope_(programming)",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:06): Rather, not at the time the function is defined, but simply at what's present in the surrounding text where the free variable occurs.",
        "ab7faae5d7b250ea8606486575f8f79c (22:07): 1f8387eb43f131d7c309a90a4e36b5cb: No, *you've* got it the wrong way round :-p",
        "ab7faae5d7b250ea8606486575f8f79c (22:07): http://foldoc.org/lexical+scope vs http://foldoc.org/dynamic+scope etc - C does lexical (static) scoping",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:08): In C:",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:08): int x = 0;",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:08): int f() { return x; }",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:08): int g() { int x = 1; return f(); }",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:08): What does g() return?",
        "ab7faae5d7b250ea8606486575f8f79c (22:08): 0",
        "ab7faae5d7b250ea8606486575f8f79c (22:08): because it's not dynamic scoping",
        "ab7faae5d7b250ea8606486575f8f79c (22:09): and the references to x are resolved statically at compile-time",
        "ab7faae5d7b250ea8606486575f8f79c (22:09): based on lexical information, not dynamic run-time information",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:09): I could have *sworn* C-likes used dynamic scoping.  Guess I'm misremembering my high-school days.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:10): In any case, CL and Scheme are both lexical-scope languages, except for their special variables.",
        "ab7faae5d7b250ea8606486575f8f79c (22:10): It would be really weird if C did dictionary lookups on every variable reference",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:11): It doesn't need dictionary lookups to implement dynamic scope.  You just keep a stack around for each binding, pushing and popping as you move between scopes.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:14): Man, what is *up* with that foldoc article.  I *assure* you that &quot;(setf x 0) (defun f () x) (defun g () (let ((x 1)) (f))) (g)&quot; returns 0.  Emacs-lisp is a dynamic-scope language, and a number of early lisps were as well, but *all* modern lisps are lexical.",
        "ab7faae5d7b250ea8606486575f8f79c (22:15): What's &quot;modern&quot;?",
        "ab7faae5d7b250ea8606486575f8f79c (22:15): That page was last updated 13 years ago",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:16): Common Lisp and anything created after it.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:16): Wow, no wonder.  CL was a new guy at that point.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:16): Jeezus.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:17): So in conclusion: I had it the right way round, I was just misremembering my C.",
        "1f8387eb43f131d7c309a90a4e36b5cb (22:21): Unrelated: Just got my first &quot;Good Answer&quot; badge on SO with a question about &lt;video&gt;.  ^_^"
    ],
    "person_ids": [
        "1f8387eb43f131d7c309a90a4e36b5cb",
        "e0563cc2e83070e74ce7019226dd654d",
        "ab7faae5d7b250ea8606486575f8f79c"
    ]
}