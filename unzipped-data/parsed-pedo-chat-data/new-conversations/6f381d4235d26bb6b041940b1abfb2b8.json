{
    "id": "6f381d4235d26bb6b041940b1abfb2b8",
    "messages": [
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:18): 73c8ec97fe210f482d81a5f04e5e6642: and how do you define error handling with ABNF/regex?",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:19): you don't have to",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:19): charset sniffing doesn't do error handling",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:20): 73c8ec97fe210f482d81a5f04e5e6642: the majority of the tokeniser does, though",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:20): the tokeniser is more complex",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:21): but even that could be &quot;more formalised&quot; than it currently is",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:21): 73c8ec97fe210f482d81a5f04e5e6642: then where were you going to use ABNF/regex? in the document conformance section?",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:21): I'm just looking at charset sniffing now",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:23): currently it is defined imperatively: go forward one byte, if it's this then goto step 1, otherwise step 2...",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:23): trying to work out how to implement things without using regex when given like that can get rather complex",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:25): eh? you mean if I give you a regular expression you don't know what to do with it, or what?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:25): I mean trying to implement a complex regular expression without using regular expressions can be hard to work out",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:26): well, not really; regular expressions can be transformed into code mechanically",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:26): unlike prose.",
        "a924fb58d2c25874322f4e5126f608b9 (14:27): The regular expressions have to be created from prose first, though",
        "ab7faae5d7b250ea8606486575f8f79c (14:27): Would BNF be easier to understand and less line-noise-like than regular expressions, but still work about the same?",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:28): yes",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:28): BNF is slightly easier, yes",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:28): you would create definitions for commonly used bits",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:28): avoid regular expression style shorthand",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:28): more like the EBNF in the XML spec",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:29): I have a preference of ABNF, personally",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:29): Comment ::= '&lt;!--' Char* '--&gt;'",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:29): (as a rough example)",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:32): tree construction is now 63 lines...",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:32): two simple functions :)",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:33): sounds good!",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:34): still doesn't really know how to parse URIs without using regular expressions, when you don't know how many parts of the URI you have",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:35): you mean like optional query parameters or port numbers?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:35): or schemes, or authority, etc.",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:36): it's pretty horrible",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:37): :)",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:37): I can think of ways of doing it, but all very expensive",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:37): and in a non-cached interpreted language\u201a\u00c4\u00b6",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:38): the overlap between URLs and filenames makes things even worse",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:39): c:foo is a filename, not a URL with scheme &quot;c&quot;",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:39): of course, http://slashdot.org is a valid filename on Linux...",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:40): what FSes is it not valid on?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:41): NTFS?",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:47): so it will become a little longer I'm afraid",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:47): need to deal with after the last closing tag too",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:47): oops",
        "a11aabeeceeae6b8cb5d12ea06b56554 (14:50): only two exams left this year!",
        "73c8ec97fe210f482d81a5f04e5e6642 (15:06): Windows won't like http://... as a filename I suspect",
        "a924fb58d2c25874322f4e5126f608b9 (15:10): \\/:*?&quot;&lt;&gt;| are illegal",
        "73c8ec97fe210f482d81a5f04e5e6642 (15:10): but anyway, if you try to use &quot;http://...&quot; as a filename, many programs will treat it as a URL instead",
        "73c8ec97fe210f482d81a5f04e5e6642 (15:11): 'cos it starts with http:",
        "73c8ec97fe210f482d81a5f04e5e6642 (15:11): can't really blame them",
        "a11aabeeceeae6b8cb5d12ea06b56554 (15:28): Mac OS X won't like http:// as a filename, but HFS+ doesn't care. You can actually create a file called that going through the POSIX layers of OS X"
    ],
    "person_ids": [
        "a11aabeeceeae6b8cb5d12ea06b56554",
        "73c8ec97fe210f482d81a5f04e5e6642",
        "a924fb58d2c25874322f4e5126f608b9",
        "ab7faae5d7b250ea8606486575f8f79c",
        "edb259c0e0038f38bb200bc20c8cbf7e"
    ]
}