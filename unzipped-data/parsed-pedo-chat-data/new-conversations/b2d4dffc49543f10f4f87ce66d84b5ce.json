{
    "id": "b2d4dffc49543f10f4f87ce66d84b5ce",
    "messages": [
        "9a8bfeabff235039fc230be48fa20583 (02:00): so how about class.Finalize() or something",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:00): in c++/cli, delete can be called on a IDisposable type",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:00): JackRyan: no, you can't do it; let the GC handle it",
        "9a8bfeabff235039fc230be48fa20583 (02:00): <a href=\"http://pastebin.com/768329\">http://pastebin.com/768329</a>",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:00): or have the C# type implement IDisposable",
        "9a8bfeabff235039fc230be48fa20583 (02:00): Thats what I have, should I implement IDispoable instea",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:00): you should implement both",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:01): IDisposable.Dispose should supress finalization",
        "9a8bfeabff235039fc230be48fa20583 (02:01): Can you show me a snippet?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:01): <a href=\"http://msdn2.microsoft.com/en-us/system.idisposable.aspx\">http://msdn2.microsoft.com/en-us/system.idisposable.aspx</a>",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:02): that is the recommended pattern",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:03): which is why c++/cli implements it inherently",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:03): a destructor implements exactly that pattern",
        "9a8bfeabff235039fc230be48fa20583 (02:03): why isnt this pattern implemented as a language feature in C#",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:04): that's a question for hans",
        "9a8bfeabff235039fc230be48fa20583 (02:04): whats the point of calling Dispose(false) in the Finalizer",
        "9a8bfeabff235039fc230be48fa20583 (02:04): if Dispose(bool) doesn't **do** anything when the disposing value is false?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:04): to ensure it is still cleaned up if no one called IDisposable.Dispose, the false just prevents any field references from being disposed",
        "9a8bfeabff235039fc230be48fa20583 (02:05): ah wait, i misread the code..",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:05): a type that implements IDisposable should (must) call Dispose on all IDisposable references it holds",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:05): fxcop complains about that",
        "9a8bfeabff235039fc230be48fa20583 (02:05): it disposes of the unmanaged resources either way? how does that work?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:05): if the user of the type does not call Dispose, the object will be marked for finalization when collected because it implements a finalizers",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:06): -s",
        "9a8bfeabff235039fc230be48fa20583 (02:06): I think I see.. it leaves the managed resources to be GCd later",
        "9a8bfeabff235039fc230be48fa20583 (02:06): this is crying out to be implemented into the language though",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:06): yep; the IDisposable pattern allows users to control it if they want to",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:08): another thing i really like about C++/CLI is that is enables auto storage semantics for reference types;  in this case, if your C# type implemented IDisposable, and you wanted to ensure Dispose was called when the object went out of scope, you'd declare it as &quot;Foo f;&quot;",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:09): essentially the C# using statement",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:10): c++/cli makes managed development a lot more c++ like, compared to managed extensions for c++",
        "9a8bfeabff235039fc230be48fa20583 (02:10): peterhu: you mean as if the object was on the stack?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:10): correct",
        "9a8bfeabff235039fc230be48fa20583 (02:10): wow",
        "9a8bfeabff235039fc230be48fa20583 (02:11): i wish i had VS2005:(",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:14): JackRyan: herb sutter's c++/cli design rationale, <a href=\"http://www.gotw.ca/publications/C\">http://www.gotw.ca/publications/C</a>++CLIRationale.pdf",
        "9a8bfeabff235039fc230be48fa20583 (02:14): and here i thought that mcpp and cpp/cli was the same",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:14): a good read",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:14): oh no",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:14): c++/cli is an ECMA standard, becoming an ISO standard",
        "9a8bfeabff235039fc230be48fa20583 (02:14): wow",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:14): managed extensions for c++ are a propriety extension, and a bad one at that",
        "9a8bfeabff235039fc230be48fa20583 (02:14): any other compilers that support it though?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:15): none that i know of yet, though herb sutter and friends were working with other vendors for adoption",
        "9a8bfeabff235039fc230be48fa20583 (02:15): would be cool if g   could do it",
        "9a8bfeabff235039fc230be48fa20583 (02:15): gcc*",
        "9a8bfeabff235039fc230be48fa20583 (02:15): so Cpp/CLI doesn't necessarily have to use dotNET?",
        "87cd1351d2d8d409774d382259a976f5 (02:16): well it's a CLI language, obviously",
        "87cd1351d2d8d409774d382259a976f5 (02:16): but it doesn't have to run on the MS CLR",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:16): i think there's a gcc frontend project on it, but i don't know it's progres (cxxcli)",
        "9a8bfeabff235039fc230be48fa20583 (02:16): what is CLI again, common language implementation?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:16): infrastructure",
        "9a8bfeabff235039fc230be48fa20583 (02:16): oh ok.. maybe mono? :)",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:16): a student does the gcc frontend as part of google's summer of code for Mono",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:17): afaik",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:17): mono 2.0 should be able to reference c++/cli assemblies (c++/cli is easily capable of producing safe and pure assemblies)",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:17): but there's no plans to support a compiler, afaik",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:17): no point imho",
        "9a8bfeabff235039fc230be48fa20583 (02:17): wont Cpp/CLI still support native code?",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:18): dunno when 2.0 will be ready",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:18): it will (through a term called &quot;c++ interop&quot;), but not in safe and pure modes",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:18): there is quite a lot of work till it",
        "9a8bfeabff235039fc230be48fa20583 (02:18): There's always a point.. cant have true open source code if you have to compile it in visual studio eh?",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:18): heh that is a stupid statement....",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:18): you don't have to",
        "9a8bfeabff235039fc230be48fa20583 (02:19): if it costs several hundred $ just to be able to compile it..",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:19): man i hate acrobat reader heh",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:19): and here i thought firefox was hung",
        "9a8bfeabff235039fc230be48fa20583 (02:19): now theres probably some kind of free compiler for it, but who knows how nice the licensing is",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:19): nope, just an update dialog that popped up under the browser window",
        "dd86a7bc62e5daaea01fb0c19f41aee0 (02:19): while debugging, how to break if a variable reaches a particular value?",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:19): a breakpoint condition",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:20): i don't know C++ very well, but I don't see the point in C++/CLI when there is C#",
        "87cd1351d2d8d409774d382259a976f5 (02:20): be warned that conditional breakpoints slow things down a lot",
        "87cd1351d2d8d409774d382259a976f5 (02:20): i-nZ, it's for interop, that's all",
        "9a8bfeabff235039fc230be48fa20583 (02:20): probably mixing native code easier",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:20): well, certainly less than a breakpoint without a condition would",
        "dd86a7bc62e5daaea01fb0c19f41aee0 (02:21): thanks",
        "87cd1351d2d8d409774d382259a976f5 (02:21): a regular breakpoint doesn't really slow down perceptibly",
        "87cd1351d2d8d409774d382259a976f5 (02:21): the condition really grinds it down",
        "87cd1351d2d8d409774d382259a976f5 (02:21): but if that's what you need, that's what you need",
        "78dbc21d2902c96d3067f18f609ca04c (02:21): lol a regular breakpoint couldn't slow it much more really ;)",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:21): a conditional breakpoint still int3s, evaluates an expression, and depending on the result, breaks or continues it",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:21): nothing you wouldn't have to do manually",
        "9a8bfeabff235039fc230be48fa20583 (02:22): peterhu: does this look better? <a href=\"http://pastebin.com/768415\">http://pastebin.com/768415</a>",
        "87cd1351d2d8d409774d382259a976f5 (02:22): i can't really say anything about WHY conditional breaks are slow",
        "87cd1351d2d8d409774d382259a976f5 (02:22): they just are",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:23): if they're slow, it's likely a result of the managed EE",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:23): dunno how they are implemented in a managed environment",
        "87cd1351d2d8d409774d382259a976f5 (02:23): they're pretty slow in unmanaged code too",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:23): but may be it is because the code actually breaks and checks the condition :)",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:24): JackRyan: close; the if (disposing) conditional in Dispose(bool) should be responsible for calling Dispose on any held reference on IDisposable types",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a (02:24): then continues if it is false",
        "69e2e9b6faa43ce63a2ecee941ecc641 (02:24): they're slow because god is punshing the use of GOTO",
        "69e2e9b6faa43ce63a2ecee941ecc641 (02:24): GOTO is considered harmful",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:24): you should be closing the stream irrespect of disposing",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:24): so if you have no IDisposable contained types, it should just be if (!disposed) { close_stream(); disposed = true }",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:25): note: TcpClient is IDisposable",
        "94f6fe9e8f4c2f6177cb923a730b1759 (02:26): so it really should be: if (!disposed) { if (disposing) myClient.Dispose(); disposed = true; }",
        "9a8bfeabff235039fc230be48fa20583 (02:26): oh"
    ],
    "person_ids": [
        "9a8bfeabff235039fc230be48fa20583",
        "94f6fe9e8f4c2f6177cb923a730b1759",
        "87cd1351d2d8d409774d382259a976f5",
        "0ded3c5d7daaf36aa8c2e1d8479a0c5a",
        "dd86a7bc62e5daaea01fb0c19f41aee0",
        "78dbc21d2902c96d3067f18f609ca04c",
        "69e2e9b6faa43ce63a2ecee941ecc641"
    ]
}