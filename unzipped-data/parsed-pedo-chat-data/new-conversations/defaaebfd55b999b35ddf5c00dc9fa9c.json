{
    "id": "defaaebfd55b999b35ddf5c00dc9fa9c",
    "messages": [
        "b8810fee2f4a71f849f3f7409546d1d9 (23:04): wonders why the charset meta sniffing algorithm bothers to upper-case attribute values",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:19): lower-case that is",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:23): it compares one of the attribute values, no?",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:26): gotta love people who admit that the use cases are extremely rare but STILL want the feature",
        "a11aabeeceeae6b8cb5d12ea06b56554 (23:29): can we have every accessibility feature possible, regardless of the size of the use case?",
        "a924fb58d2c25874322f4e5126f608b9 (23:35): What if we have invisible aliens who interact through sandpaper rasping sounds",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:36): There are probably simpler cases that are not addressed :)",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:40): 69b0d3dfe919a6b860a9fac82de52a7e: yeah, it says &quot;If the next six characters are not 'charset'&quot;",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:41): 69b0d3dfe919a6b860a9fac82de52a7e: is continuing when the tentative encoding is unknown the current browser behavior?",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:42): (sorry if you answered already and the answer slipped by my scrollback)",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:43): 69b0d3dfe919a6b860a9fac82de52a7e: is it intentional that the sniffing algorithm talks about supported encodings and not supported *rough ASCII superset* encodings?",
        "65325d50b2e25aca54bc871b89758c9c (23:46): one quirk in Safari is that if there's a meta tag claiming the source is utf-16, we treat it as utf-8",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:46): is that a bug or actually needed?",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:46): 65325d50b2e25aca54bc871b89758c9c: is that a bug that stuck or is it needed by content out there?",
        "65325d50b2e25aca54bc871b89758c9c (23:47): (that's assuming there was no content-type header claiming otherwise)",
        "a924fb58d2c25874322f4e5126f608b9 (23:47): If it's utf-16, it wouldn't be able to decode using the ascii process, right?",
        "65325d50b2e25aca54bc871b89758c9c (23:47): b8810fee2f4a71f849f3f7409546d1d9: there is content that needs it",
        "65325d50b2e25aca54bc871b89758c9c (23:47): and if it was really utf-16, you wouldn't have found the meta tag",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:47): got to love the web",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:48): 65325d50b2e25aca54bc871b89758c9c: ok. what about UTF-32? :-)",
        "a924fb58d2c25874322f4e5126f608b9 (23:49): The new scrollIntoView says to scroll the -document- into view for the true case. Am I right in seeing that as an error?",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:50): b8810fee2f4a71f849f3f7409546d1d9: dunno, haven't really looked into it recently. probably need to fix things up in the spec.",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:51): fyi: I heard lots of people complain about the charset finding byte algorithm",
        "65325d50b2e25aca54bc871b89758c9c (23:51): b8810fee2f4a71f849f3f7409546d1d9: I think we may treat any claimed unicode charset in a &lt;meta&gt; tag as utf-8",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:52): 65325d50b2e25aca54bc871b89758c9c: ok",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:52): sends an email to get this on record",
        "65325d50b2e25aca54bc871b89758c9c (23:52): (I think maybe same for xml declarations)",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:52): Why would people write UTF-8 and then claim it's UTF-32?!",
        "b8810fee2f4a71f849f3f7409546d1d9 (23:53): 65325d50b2e25aca54bc871b89758c9c: that would be dirty and very un-XML :-)",
        "65325d50b2e25aca54bc871b89758c9c (23:53): edb259c0e0038f38bb200bc20c8cbf7e: because Win IE handles it?",
        "65325d50b2e25aca54bc871b89758c9c (23:53): b8810fee2f4a71f849f3f7409546d1d9: maybe we just reject such cases for XML, I dunno",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:53): edb259c0e0038f38bb200bc20c8cbf7e: any specific complaints?",
        "65325d50b2e25aca54bc871b89758c9c (23:55): actually we do hack it for xml declarations",
        "65325d50b2e25aca54bc871b89758c9c (23:55): if (source == EncodingFromMetaTag || source == EncodingFromXMLHeader || source == EncodingFromCSSCharset)",
        "65325d50b2e25aca54bc871b89758c9c (23:55): m_decoder.reset(encoding.closest8BitEquivalent());",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:55): 69b0d3dfe919a6b860a9fac82de52a7e, the English algorithm was more complex than the implementation, for one",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:56): 69b0d3dfe919a6b860a9fac82de52a7e, b8810fee2f4a71f849f3f7409546d1d9 mentioned earlier that the algorithm &quot;encouraged&quot; look-ahead",
        "65325d50b2e25aca54bc871b89758c9c (23:56): closest8BitEquivalent currently only translates UTF16 (including BE and LE variants) to UTF-8",
        "edb259c0e0038f38bb200bc20c8cbf7e (23:56): I believe jgraham had some thoughts about it as well, but I don't recall them",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:56): edb259c0e0038f38bb200bc20c8cbf7e: ah, yeah, it's not as close to an implementation as the parser",
        "69b0d3dfe919a6b860a9fac82de52a7e (23:57): edb259c0e0038f38bb200bc20c8cbf7e: mostly because i didn't implement it :-)"
    ],
    "person_ids": [
        "b8810fee2f4a71f849f3f7409546d1d9",
        "69b0d3dfe919a6b860a9fac82de52a7e",
        "a11aabeeceeae6b8cb5d12ea06b56554",
        "a924fb58d2c25874322f4e5126f608b9",
        "edb259c0e0038f38bb200bc20c8cbf7e",
        "65325d50b2e25aca54bc871b89758c9c"
    ]
}