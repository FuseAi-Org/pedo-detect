{
    "id": "3d30fb7ca208944695240bd73b61ffb1",
    "messages": [
        "b8810fee2f4a71f849f3f7409546d1d9 (18:16): weird. Am I reading correctly that the Python gzip module wants to read for a file and won't read form another kind of source?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:17): hmm. I guess I can pass a fileObj and a bogus name...",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:18): ah. diveintopython to rescue",
        "ab7faae5d7b250ea8606486575f8f79c (18:18): Can you use plain zlib instead?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:19): ab7faae5d7b250ea8606486575f8f79c: it looks complicated",
        "ab7faae5d7b250ea8606486575f8f79c (18:19): output = zlib.decompress(input) ? :-)",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:19): gzip.GzipFile(fileobj=foo)",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:20): ab7faae5d7b250ea8606486575f8f79c: does decompress skip over gzip header and deal with the CRC?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:22): in related news, I had regressed &amp;out=text. works now. sorry",
        "ab7faae5d7b250ea8606486575f8f79c (18:25): It sounds like zlib.decompress handles the &quot;standard gzip header&quot; (unless you pass it negative wbits)",
        "ab7faae5d7b250ea8606486575f8f79c (18:25): but I don't know if it's exactly the same header, or if it does the right kind of checksum too",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:28): if response.getheader('Content-Encoding', 'identity').lower() == 'gzip': response = gzip.GzipFile(fileobj=StringIO.StringIO(response.read()))",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:28): that works",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:29): How badly does gzip break streamability, though?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:29): surely it can't break it beyond its compression window?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:30): how would piping gigabytes of data to gzip work otherwise?",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:30): markp explains GzipFile is being difficult because it needs random access to the fileobj",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:33): http://about.validator.nu/html5check.py now uses compression",
        "cc097e0d7183ae8436e7df709553c8c0 (18:43): adds form[action$=&quot;validator.nu/&quot;] ~ *, form[action$=&quot;validator.nu/&quot;] ~ * b { font-weight:normal !important; } to his user.css :)",
        "a924fb58d2c25874322f4e5126f608b9 (18:46): And to think CSS used to be readable",
        "cc097e0d7183ae8436e7df709553c8c0 (18:47): krijnh: you could change the color of the box only when you hover the actual box -- not when you hover the line",
        "cc097e0d7183ae8436e7df709553c8c0 (18:48): krijnh: that would make it less distracting when reading :)",
        "cc097e0d7183ae8436e7df709553c8c0 (18:49): krijnh: or use checkboxes instead?",
        "cc097e0d7183ae8436e7df709553c8c0 (18:52): hmm, the ui fonts can expose to js what os theme the user has",
        "cc097e0d7183ae8436e7df709553c8c0 (18:53): dunno how that could be used",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:53): cc097e0d7183ae8436e7df709553c8c0: could be used for UI spoofing",
        "cc097e0d7183ae8436e7df709553c8c0 (18:53): b8810fee2f4a71f849f3f7409546d1d9: yeah",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:54): cc097e0d7183ae8436e7df709553c8c0: although the whole CSS UI font idea is intended for white-hat UI consistency",
        "b8810fee2f4a71f849f3f7409546d1d9 (18:54): which is what I'm trying to do, but your browser is not playing along to your taste :-(",
        "cc097e0d7183ae8436e7df709553c8c0 (18:54): indeed",
        "cc097e0d7183ae8436e7df709553c8c0 (18:55): perhaps browsers can combat ui spoofing in the same way as the visited links thing",
        "ab7faae5d7b250ea8606486575f8f79c (18:56): The UI spoofing use case seems to be handled alright by screenshotting the standard Windows UI into a GIF, judging by the adverts I see on the web",
        "ab7faae5d7b250ea8606486575f8f79c (18:56): and users don't care if minor details are not consistent with the standard UI, like if the dialog box's button is bouncing all over the place and flashing",
        "cc097e0d7183ae8436e7df709553c8c0 (18:57): ab7faae5d7b250ea8606486575f8f79c: bouncing and flashing ads are too obvious to be spoofing",
        "cc097e0d7183ae8436e7df709553c8c0 (19:02): more serious spoofing would be to imitate active x dialogs in fake bank sites",
        "cc097e0d7183ae8436e7df709553c8c0 (19:17): b8810fee2f4a71f849f3f7409546d1d9: your html5 schema doesn't allow id=&quot;&quot; on &lt;title&gt; it seems",
        "cc097e0d7183ae8436e7df709553c8c0 (19:20): b8810fee2f4a71f849f3f7409546d1d9: or any attributes on &lt;title&gt;",
        "cc097e0d7183ae8436e7df709553c8c0 (19:38): b8810fee2f4a71f849f3f7409546d1d9: is the reason you don't have upload and textarea that you don't know how to integrate it nicely in the ui?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:49): wonders what happens according to the spec if you have a &lt;title&gt; element within .innerHTML on a |div|",
        "cc097e0d7183ae8436e7df709553c8c0 (19:50): a11aabeeceeae6b8cb5d12ea06b56554: when setting innerHTML?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:50): cc097e0d7183ae8436e7df709553c8c0: yeah",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:52): if it the fragment algorithm returns all the children of the root |html|, surely it'll return things like |head| for every fragment?",
        "cc097e0d7183ae8436e7df709553c8c0 (19:53): a11aabeeceeae6b8cb5d12ea06b56554: no, the parsing algorithm has fragment case checks",
        "cc097e0d7183ae8436e7df709553c8c0 (19:54): a11aabeeceeae6b8cb5d12ea06b56554: also, fragment parsing starts in the main phase",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:54): surely it starts with the insertion mode as &quot;before head&quot;?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:55): then when it reaches the &quot;any other start tag token&quot; case it creates a |head| element",
        "cc097e0d7183ae8436e7df709553c8c0 (19:55): a11aabeeceeae6b8cb5d12ea06b56554: depends on the context element",
        "cc097e0d7183ae8436e7df709553c8c0 (19:55): i think",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:55): all the context element affects is the content model flag",
        "cc097e0d7183ae8436e7df709553c8c0 (19:56): ok",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:56): actually, it calls the  insertion mode appropriately algorithm",
        "a11aabeeceeae6b8cb5d12ea06b56554 (19:59): insertion mode starts as &quot;in body&quot;",
        "cc097e0d7183ae8436e7df709553c8c0 (20:00): regardless of the context element?",
        "a11aabeeceeae6b8cb5d12ea06b56554 (20:00): no, in the case of |div| (as per my question)",
        "cc097e0d7183ae8436e7df709553c8c0 (20:03): right",
        "cc097e0d7183ae8436e7df709553c8c0 (20:04): you process the &quot;title&quot; start tag token as if the insertion mode was in head",
        "cc097e0d7183ae8436e7df709553c8c0 (20:05): which says: &quot;Follow the generic RCDATA parsing algorithm, with the head element pointer as the context node, unless that's null, in which case use the current node (fragment cose).&quot;",
        "cc097e0d7183ae8436e7df709553c8c0 (20:05): the head element pointer will be null in your case",
        "a11aabeeceeae6b8cb5d12ea06b56554 (20:05): so it just goes where it was in the source?",
        "cc097e0d7183ae8436e7df709553c8c0 (20:06): yeah, seems so"
    ],
    "person_ids": [
        "b8810fee2f4a71f849f3f7409546d1d9",
        "ab7faae5d7b250ea8606486575f8f79c",
        "cc097e0d7183ae8436e7df709553c8c0",
        "a924fb58d2c25874322f4e5126f608b9",
        "a11aabeeceeae6b8cb5d12ea06b56554"
    ]
}