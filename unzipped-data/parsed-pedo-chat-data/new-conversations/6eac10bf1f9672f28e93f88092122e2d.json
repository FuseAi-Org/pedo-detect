{
    "id": "6eac10bf1f9672f28e93f88092122e2d",
    "messages": [
        "69b0d3dfe919a6b860a9fac82de52a7e (05:46): aa: ping",
        "69b0d3dfe919a6b860a9fac82de52a7e (05:47): aa: the second example in http://code.google.com/p/google-gears/wiki/HigherLevelDatabaseAPI uses |row| without declaring it",
        "65325d50b2e25aca54bc871b89758c9c (06:11): 69b0d3dfe919a6b860a9fac82de52a7e: presumably the intent is var row = rows[i] inside the loop",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:14): i assume so, yeah",
        "65325d50b2e25aca54bc871b89758c9c (06:16): 69b0d3dfe919a6b860a9fac82de52a7e: I think it would be better to use a pseudo-array for the rows instead of a literal JS array, and especially so for the object representing an individual result row",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:16): but we want it to inherit whatever is on the Array prototype",
        "65325d50b2e25aca54bc871b89758c9c (06:17): most functions on the Array prototype are generic, so it's possible to require inheriting them without requiring being an array",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:17): sounds complex",
        "65325d50b2e25aca54bc871b89758c9c (06:18): (&quot;generic&quot; in the sense that they are required to work on any JS object that has numeric properties and a property named &quot;length&quot;)",
        "65325d50b2e25aca54bc871b89758c9c (06:18): (by ECMAScript)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:18): other than increasing the complexity of the spec, what is gained by making it not an object?",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:18): er",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:18): not an Array",
        "65325d50b2e25aca54bc871b89758c9c (06:19): it's harder to do lazy computation tricks while literally subclassing JS array, and it's not clear if the few non-generic Array methods are desired here",
        "65325d50b2e25aca54bc871b89758c9c (06:19): in any case, it's more obvious to me for the objects representing a row, since you want both named and indexed access",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:19): the objects representing the row are just Object elements",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:19): er",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:19): Object objects",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:19): as it were",
        "65325d50b2e25aca54bc871b89758c9c (06:20): yes, I know",
        "65325d50b2e25aca54bc871b89758c9c (06:20): that leaves out any way to do index-based operations",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:20): just enumerate them",
        "65325d50b2e25aca54bc871b89758c9c (06:20): (thought if they chose to implementations could still do lazy computation for the properties)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:20): for (field in row) { ... }",
        "65325d50b2e25aca54bc871b89758c9c (06:21): for..in loops are somewhat inefficient in JS, and while you can do similar things to forEach, filter and map, being able to use functional programming style directly can be handy",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:21): i guess we can make them custom objects implementing interfaces specific for this case, but that basically just makes the spec complicated without an obvious gain as far as i can tell",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:22): i don't really see what the use case is for non-named access to the fields",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:24): (debugging being the exception, but it's not like performance is a high priority there)",
        "65325d50b2e25aca54bc871b89758c9c (06:35): indexed access is likely to be higher-performance than named access, even in a non-looping context",
        "65325d50b2e25aca54bc871b89758c9c (06:36): though probably harder to read, if you just did that directly",
        "65325d50b2e25aca54bc871b89758c9c (06:36): FWIW in WebKit we'd probably implement it as a custom object subclass anyway, if only to make conversion from SQLite API data types to JS types lazy",
        "65325d50b2e25aca54bc871b89758c9c (06:37): at which point is seems gratuitous not to offer indexed as well as named access",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:38): i'd expect it to be implemented as a subclass, yes",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:38): i can make the object have non-enumerable numeric properties",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:39): but i don't want to give it a &quot;length&quot; property",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:39): or any other named properties for that matter (like namedItem())",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:39): since anything i add here is a column name you can't use",
        "65325d50b2e25aca54bc871b89758c9c (06:41): well, it would be a column name that it would be inconvenient to use, at the very least (since you could always use function accessors for such a column, if there were a complete set)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:42): that would be really confusing",
        "65325d50b2e25aca54bc871b89758c9c (06:42): non-enumerable numeric properties are somewhat less valuable without &quot;length&quot;, since you can't use any array functions",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:42): i agree",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:42): but &quot;length&quot; seems like something you'd want to call a column relatively often",
        "65325d50b2e25aca54bc871b89758c9c (06:42): but it does seem like &quot;length&quot; might be a likely column name",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:43): we could put the number of fields on SQLResultSet, though that doesn't help you use generic methods",
        "65325d50b2e25aca54bc871b89758c9c (06:43): I guess I'm sort of convinced that it's better not to have a special interface",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:44): it's a weird set of constraints",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:44): i don't really know how best to handle it",
        "65325d50b2e25aca54bc871b89758c9c (06:44): it looks like the only array methods that are not rebindable are toString and toLocaleString",
        "65325d50b2e25aca54bc871b89758c9c (06:45): so if you override those it's possible to inherit the array prototype without inheriting from the Array implementation is the &quot;class&quot; sense",
        "65325d50b2e25aca54bc871b89758c9c (06:45): (that's in reference to the rows array)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:46): is that preferable to just implementing an Array internally?",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:46): it's distinguishable at the JS level, so it's not like the spec can punt on this",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): notes that having a variadic set of arguments on sqlExecute in the _middle_ of the arguments list is probably going to cause issues in non-JS languages",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): but you really want the callback at the end",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): maybe we should always require the array syntax",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): executeSql(['sql', arguments...], callback)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): no wait",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): it would be",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): executeSql([['sql', arguments...]], callback)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:47): boy is that ugly",
        "65325d50b2e25aca54bc871b89758c9c (06:47): yeah",
        "65325d50b2e25aca54bc871b89758c9c (06:48): non-JS languages could certainly implement only the array version",
        "65325d50b2e25aca54bc871b89758c9c (06:48): you can't really express the other version well in the type system of any statically typed language",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:49): not without a buttload of overloads, no",
        "65325d50b2e25aca54bc871b89758c9c (06:50): how is it distinguishable at the JS level whether you subclass Array or just have its prototype in your prototype chain?",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:50): well if it's not, it doesn't matter what the spec says",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:51): but as far as I can tell, an Array doesn't have a prototype chain",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:51): so you could distinguish by checking to see if it had one",
        "65325d50b2e25aca54bc871b89758c9c (06:52): an Array instance does have a prototype chain",
        "65325d50b2e25aca54bc871b89758c9c (06:52): however anything that was either a subclass of Array or for other reasons had a prototype chain that included Array's prototype would have a longer prototype chain",
        "65325d50b2e25aca54bc871b89758c9c (06:53): your spec, if read literally, would possibly rule out a custom subclass of Array",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:53): why?",
        "65325d50b2e25aca54bc871b89758c9c (06:53): since it says &quot;must return a native array of objects&quot;",
        "65325d50b2e25aca54bc871b89758c9c (06:53): assuming you mean &quot;native&quot; in the sense of the ECMAScript spec",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:54): you can implement a native array however you like",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:54): it does disallow a different prototype chain length, though, yes",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:54): (var x = new Array(); x.__prototype__; returns 'undefined' in mozilla.)",
        "65325d50b2e25aca54bc871b89758c9c (06:55): I think the property is named __proto__",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:55): ah",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:55): checks that",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:56): var x = new Array(); x.__proto__ == Array.prototype; returns true",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:56): so yes",
        "65325d50b2e25aca54bc871b89758c9c (06:56): so anyway that constraint seems of marginal value to JS coders and would make it hard to implement as a custom Array subclass in at least Gecko and WebKit afaik",
        "65325d50b2e25aca54bc871b89758c9c (06:57): (probably not impossible, but shouldn't simplicity of implementation trump simplicity of the spec?)",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:57): yes it should",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:57): so what would you want it to say?",
        "65325d50b2e25aca54bc871b89758c9c (06:58): I'm not sure",
        "65325d50b2e25aca54bc871b89758c9c (06:58): another issue with Array is that it has to allow adding arbitrary array properties and those must be reflected in &quot;length&quot; and in behavior of the array methods",
        "65325d50b2e25aca54bc871b89758c9c (06:58): which would make a completely custom implementation that used a different backing store even harder",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:59): yeah i'd be ok with making it immutable",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:59): so you'd want something that had a length and an item() method?",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:59): we really need a way to make these objects enumerable in JS",
        "69b0d3dfe919a6b860a9fac82de52a7e (06:59): same problem with NodeList, et al",
        "65325d50b2e25aca54bc871b89758c9c (07:00): yes, NodeList's non-arrayness is inconvenient",
        "65325d50b2e25aca54bc871b89758c9c (07:01): thinking...",
        "65325d50b2e25aca54bc871b89758c9c (07:01): I think giving the row list item(), a read-only length, indexed access via array syntax, and requiring that it have all normal methods of Array would make implementation not too hard and would give JS coders all they need",
        "65325d50b2e25aca54bc871b89758c9c (07:02): similar requirements could be placed on NodeList et al for convenience",
        "65325d50b2e25aca54bc871b89758c9c (07:02): the downside is you couldn't use any of the mutating array methods usefully since they all modify length",
        "65325d50b2e25aca54bc871b89758c9c (07:02): maybe it is better not to have them than to have non-working versions",
        "69b0d3dfe919a6b860a9fac82de52a7e (07:02): yeah i'm not sure how to require that though",
        "69b0d3dfe919a6b860a9fac82de52a7e (07:04): i'm really not sure how to handle errors with the array form of executeSql",
        "69b0d3dfe919a6b860a9fac82de52a7e (07:04): doesn't really want to add it",
        "65325d50b2e25aca54bc871b89758c9c (07:04): &quot;all methods available on Array instances except those that may modify any property of the array",
        "65325d50b2e25aca54bc871b89758c9c (07:04): 69b0d3dfe919a6b860a9fac82de52a7e: the form that lets you pass an array of statements?",
        "69b0d3dfe919a6b860a9fac82de52a7e (07:04): yeah",
        "65325d50b2e25aca54bc871b89758c9c (07:04): it doesn't seem super essential",
        "65325d50b2e25aca54bc871b89758c9c (07:05): but you could say in case of error the callback is delivered after the first error, with only as the ResultSets for the successful statements up to the first failing one, plus the first failing one"
    ],
    "person_ids": [
        "69b0d3dfe919a6b860a9fac82de52a7e",
        "65325d50b2e25aca54bc871b89758c9c"
    ]
}