{
    "id": "eb14b6f522d64ee783ead449bcf63223",
    "messages": [
        "b8810fee2f4a71f849f3f7409546d1d9 (17:52): https://twitter.com/#!/ndw/status/15373943112204288",
        "b8810fee2f4a71f849f3f7409546d1d9 (17:53): probably a high cost relative the number of switchers attracted",
        "edb259c0e0038f38bb200bc20c8cbf7e (18:06): haha",
        "79b7d68816776b057c779356a1be4b47 (18:10): embedding a theora stream (from a VLC server) works until the stream moves on to a new playlist item. viewing it in VLC works fine. is there a way to force the &lt;video&gt; element to stay connected across multiple playlist items?",
        "b25b6b77a0087ff8385941e5545d32ea (18:11): b8810fee2f4a71f849f3f7409546d1d9: I estimate we would get 1 user per XPath version",
        "edb259c0e0038f38bb200bc20c8cbf7e (18:12): before XSLT 2.0 we should do XQueryX",
        "edb259c0e0038f38bb200bc20c8cbf7e (18:13): oh, and provide http://www.w3.org/TR/HTTP-in-RDF10/ as output format for developer tools",
        "e83147fdd1c7a8c2b85b2d842011b173 (18:15): b25b6b77a0087ff8385941e5545d32ea: but very nice users they would be",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:22): edb259c0e0038f38bb200bc20c8cbf7e: (responding to the sorting issue from earlier) You can pass custom comparator functions to sort.",
        "b25b6b77a0087ff8385941e5545d32ea (18:22): e83147fdd1c7a8c2b85b2d842011b173: All our users are very nice, I'm sure :)",
        "b25b6b77a0087ff8385941e5545d32ea (18:22): 1f8387eb43f131d7c309a90a4e36b5cb: Yeah, but you don't want to",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:22): b25b6b77a0087ff8385941e5545d32ea: Why not?",
        "b25b6b77a0087ff8385941e5545d32ea (18:22): It's complex and slow",
        "b25b6b77a0087ff8385941e5545d32ea (18:23): So if you can avoid it then you should",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:23): Slow, okay, maybe.  Shrug.  But complex?  Hardly.",
        "b25b6b77a0087ff8385941e5545d32ea (18:23): At least I imagine it is",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:23): comes from lisp, so passing comparators to sort seems natural.",
        "b25b6b77a0087ff8385941e5545d32ea (18:23): Well you have to look up / remember what the function has to return",
        "b25b6b77a0087ff8385941e5545d32ea (18:23): for the different cases",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:24): That's easy.  Just remember the integer comparator lambda x,y: x-y",
        "ab7faae5d7b250ea8606486575f8f79c (18:24): likes Perl's custom sort syntax, since it encourages use of the spaceship operator",
        "b25b6b77a0087ff8385941e5545d32ea (18:24): 1f8387eb43f131d7c309a90a4e36b5cb: Like I said, complex",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:24): Granted, it's even easier if you can just return a bool, but that's the C legacy for you.",
        "ab7faae5d7b250ea8606486575f8f79c (18:25): my @sorted_by_increasing_age_then_decreasing_height = sort { $a-&gt;{age} &lt;=&gt; $b-&gt;{age} or $b-&gt;{height} &lt;=&gt; $a-&gt;{height} } @people; etc",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:25): That's a pretty cool operator.  What does it return?",
        "ab7faae5d7b250ea8606486575f8f79c (18:25): -1, 0, or +1",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:25): That's what I suspected.",
        "ab7faae5d7b250ea8606486575f8f79c (18:26): (There's a 'cmp' operator which does the same but with string comparison instead of numeric comparison)",
        "b25b6b77a0087ff8385941e5545d32ea (18:28): Wait, perl has operators that only take specific types? I thought perl was rather weakly typed",
        "b25b6b77a0087ff8385941e5545d32ea (18:29): In the sense of &quot;eager to do implicit type conversions&quot;",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:29): I assume that &quot;string comparison&quot; means &quot;cast to strings before comparing&quot;.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:29): Such that 9 cmp 10 return 1.",
        "b25b6b77a0087ff8385941e5545d32ea (18:30): Oh well that's just silly. There is a reason for explicit cast functions",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:30): PHP works the same way.  It's convenient except when it misbehaves and everything breaks.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:31): Like, in PHP it's a bad idea to do if (!$str) { /* assume string is empty */ }, because '0' == false.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:31): I can't count the number of MediaWiki bugs that's caused.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:31): I assume it stole the idea from Perl.",
        "ab7faae5d7b250ea8606486575f8f79c (18:31): b25b6b77a0087ff8385941e5545d32ea: The operators take any type, and always perform the same operation (e.g. a numeric comparison, or a string comparison) regardless of the dynamic type of the variables",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:31): I assume it's so that 0 means false even if it comes straight from a form.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:32): Yes.",
        "b25b6b77a0087ff8385941e5545d32ea (18:32): See also: http://twitter.com/gsnedders/status/14717708356550656",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:32): Except when you mean it to be a string and it happens to be exactly '0', it's a headache.",
        "ab7faae5d7b250ea8606486575f8f79c (18:32): (which means you never end up with bugs like doing &quot;var count = input.value + 1; // oops, the input was 0 and now count is '01'&quot; like in JS)",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:33): Like if (!$_GET['username']) { echo '&lt;strong class=error&gt;You must enter a username!&lt;/strong&gt;'; }",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:33): Oh, I agree.  It's bitten me before, and I think it's retarded.  But shrug.",
        "ab7faae5d7b250ea8606486575f8f79c (18:33): (It's silly having a language with implicit string&lt;-&gt;number conversions and then operators that do very different things depending on whether a value is currently represented as a string or a number)",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:33): That means '0' is an invalid username, oops.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:33): I think using . for string concatenation makes sense.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:34): That far it works.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:34): But the boolean casting behavior is wonky.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:34): Actually, casting altogether is wonky.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:34): Which is why I always use tests like is_set() to see if form vars have been sent, etc.",
        "b25b6b77a0087ff8385941e5545d32ea (18:34): ab7faae5d7b250ea8606486575f8f79c: I think I was happy at &quot;It's silly having a language with implicit string&lt;-&gt;number conversions&quot;",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:34): '0' == false, false == '', '' != '0'",
        "ab7faae5d7b250ea8606486575f8f79c (18:35): 88d4d34a8064a4ff39fd5e144eea7762: Perl says anything that stringifies to &quot;&quot; or &quot;0&quot; is false, I believe",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:35): That's even more horrible.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:35): At least in PHP it's only literal '' and '0'.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:35): Wait, that doesn't even make sense.",
        "ab7faae5d7b250ea8606486575f8f79c (18:35): 88d4d34a8064a4ff39fd5e144eea7762: What about the number 0?",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:35): I meant strings.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:35): Of course non-strings have their own rules.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:35): Python has sane behavior here.  Classes can define the function that tells whether they're falsy or not.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:36): Python is strictly typed.",
        "ab7faae5d7b250ea8606486575f8f79c (18:36): Perl's rules apply to all types",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:36): Which I have mixed feelings about.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:36): It feels kind of excessive to me to have to write things like &quot;Answer is &quot; + str(answer) instead of being able to just use &quot;Answer is &quot; + answer.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:36): I have to say, interpolation is really awesome.",
        "ab7faae5d7b250ea8606486575f8f79c (18:36): so 0 stringifies to &quot;0&quot;, undefined stringifies to &quot;&quot;, objects stringify to &quot;HASH(0x7d8220)&quot; (i.e. not false), etc",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:36): &quot;Answer is $answer&quot;",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:36): It's not strict, it's strong.  (Assuming strict was the opposite of dynamic?)",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:37): Strong, strict, whatever.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:37): The opposite of dynamic is static.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:37): Gah, right.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:37): Python has strong dynamic typing.",
        "ab7faae5d7b250ea8606486575f8f79c (18:37): s/objects/object references/",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:37): Too many words starting with &quot;st&quot;.",
        "b25b6b77a0087ff8385941e5545d32ea (18:37): You can do &quot;The answer is %s&quot;%answer",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:37): Use &quot;Answer is %s&quot; % answer",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:37): Dammit, b25b6b77a0087ff8385941e5545d32ea",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:37): Is there any way in Python to get something like &quot;Foo $bar baz&quot; to interpolate variables?  Something comparably uncluttered?",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:38): Yeah, but that separates the variables from the place they're put.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:38): It's considerably more awkward.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:38): Although probably better than loads of &quot; + &quot;.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:38): Well, &quot; + foo + &quot;.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:38): I find it more convenient actually, because I can see what the string will look like even with long expressions for the vars.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:38): Plus, no silly escaping rules.",
        "b25b6b77a0087ff8385941e5545d32ea (18:38): You might be able to do &quot;Foo ${bar} ${baz}&quot;%locals() but that might not work",
        "b25b6b77a0087ff8385941e5545d32ea (18:38): It would also be a hideous hack",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:39): always has to pause a bit to remember if he has to do something weird for anything more trivial than a var name in PHP.",
        "b25b6b77a0087ff8385941e5545d32ea (18:39): (I don't recall if it insists that all keys in the dict end up in the output)",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:39): Another thing that's bitten me in Python is how it concatenates adjacent strings.  Like &quot;foo&quot; &quot;bar&quot; == &quot;foobar&quot;.  That's all very nice until you declare an array of lots of strings and forget a comma at the end of the line.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:39): Then they silently merge together instead of erroring.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:39): Yeah, that's a wart.",
        "b25b6b77a0087ff8385941e5545d32ea (18:39): Yes, that can be annoying in that case",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:39): I assume it comes from C.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:40): It makes sense for C, because there's no way to concatenate strings without a function call.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:40): And Guido thought it was useful.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:40): You can just stick in a + . . .",
        "b25b6b77a0087ff8385941e5545d32ea (18:40): It is sort of useful",
        "b25b6b77a0087ff8385941e5545d32ea (18:40): But not that useful",
        "ab7faae5d7b250ea8606486575f8f79c (18:40): (Perl uses &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;==&quot;, &quot;&lt;=&gt;&quot; etc for numeric comparisons, and &quot;lt&quot;, &quot;le&quot;, &quot;eq&quot;, &quot;cmp&quot; etc for string comparisons, which is nice and consistent; but then it uses &quot;||&quot; and &quot;&amp;&amp;&quot; for normal C-like-precedence boolean operators, and &quot;or&quot; and &quot;and&quot; for lower-precedence versions of the safe functions, which is a little more confusing)",
        "ab7faae5d7b250ea8606486575f8f79c (18:40): s/safe/same/",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:40): Python just uses &quot;and&quot; and &quot;or&quot; across the board.  Much nicer.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:41): Also &quot;not&quot; and &quot;in&quot;.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:41): Down with punctuation!",
        "ab7faae5d7b250ea8606486575f8f79c (18:41): Those have C-like precedence, I think",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:41): I always forget what exactly the deal is with PHP's &quot;and&quot; and &quot;or&quot;, so I just avoid them.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:42): I used to use them in an attempt to emulate Python, but other MediaWiki developers mostly prefer &amp;&amp; and ||, so I go with the flow (at least for MW).",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:43): It's kind of like this note from our style guide: &quot;Homesick C developers write null as NULL because they want to believe that it is a macro defined as ((void*)0). This is not necessary.&quot;",
        "ab7faae5d7b250ea8606486575f8f79c (18:43): Lower precedence means you can write &quot;open $fh, $filename or die&quot; to mean &quot;if (not (open $fh, $filename)) { die; }&quot; in a more concise and threatening way",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:43): I like the &quot;threatening&quot;.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:43): Concise is, of course, typical of Perl.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:43): I must admit, that's my favorite part of dbconn classes.",
        "ab7faae5d7b250ea8606486575f8f79c (18:43): Sadly you can't write &quot;open $fh, $filename or else&quot;",
        "b25b6b77a0087ff8385941e5545d32ea (18:43): Really &quot;die&quot; as a keyword is just silly",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:43): We seem to be mostly Python people here, is that a coincidence?",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:44): b25b6b77a0087ff8385941e5545d32ea, I think it's a function, not a keyword, no?",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:44): (I could be totally wrong.)",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:44): I'm like a 5 or 6-language person.",
        "b25b6b77a0087ff8385941e5545d32ea (18:44): I dunno",
        "ab7faae5d7b250ea8606486575f8f79c (18:44): It's a built-in function",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:44): 1f8387eb43f131d7c309a90a4e36b5cb, you're a Python person if you prefer Python to Perl, regardless of whether you actually use or know either.",
        "b25b6b77a0087ff8385941e5545d32ea (18:44): 88d4d34a8064a4ff39fd5e144eea7762: I imagine the pyhon thing is pure coincidence",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:44): Hixie is a Perl person, and apparently so is ab7faae5d7b250ea8606486575f8f79c.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:44): 88d4d34a8064a4ff39fd5e144eea7762: Sure, then.",
        "ab7faae5d7b250ea8606486575f8f79c (18:44): You can define your own, e.g. the Carp module adds carp and croak etc",
        "ab7faae5d7b250ea8606486575f8f79c (18:44): which act like die but a bit different",
        "b25b6b77a0087ff8385941e5545d32ea (18:45): There  don't seem to be that many ruby people here",
        "b25b6b77a0087ff8385941e5545d32ea (18:45): Possibly that is surprising. Possibly they are all just building shit",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:45): Yeah, I've never used Ruby, though it looks interesting.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:45): Well, Ruby is much less popular overall than Perl or Python.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:45): At least last I checked.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:45): At least, outside of Japan.",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:45): It seems to have gotten more popular over the last couple of years, but Python and Perl are much better-established.",
        "b25b6b77a0087ff8385941e5545d32ea (18:45): I have never really felt the need to learn Ruby since I can use python. If I was learning another language I would pick one a bit different",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:45): (especially Perl)",
        "88d4d34a8064a4ff39fd5e144eea7762 (18:46): If I were learning a new language, it would be Lisp or Haskell or something.",
        "1f8387eb43f131d7c309a90a4e36b5cb (18:46): Both are good ideas."
    ],
    "person_ids": [
        "b8810fee2f4a71f849f3f7409546d1d9",
        "edb259c0e0038f38bb200bc20c8cbf7e",
        "79b7d68816776b057c779356a1be4b47",
        "b25b6b77a0087ff8385941e5545d32ea",
        "e83147fdd1c7a8c2b85b2d842011b173",
        "1f8387eb43f131d7c309a90a4e36b5cb",
        "ab7faae5d7b250ea8606486575f8f79c",
        "88d4d34a8064a4ff39fd5e144eea7762"
    ]
}