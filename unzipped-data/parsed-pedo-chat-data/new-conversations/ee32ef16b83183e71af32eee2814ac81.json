{
    "id": "ee32ef16b83183e71af32eee2814ac81",
    "messages": [
        "37d2de30a27c46d835b1351ae69ab8be (01:19): Should I assume that if you do partition exchange and the table you are exchanging with has an index, and you do INCLUDING INDEXES, that the index will be a LOCAL index?",
        "443a9547033ec9d695ae9d29e8df98b1 (01:20): a local index is on the partition and a global index is over the whole shebang",
        "37d2de30a27c46d835b1351ae69ab8be (01:20): right",
        "37d2de30a27c46d835b1351ae69ab8be (01:21): perhaps you aren't envisioning my grand example as I am",
        "37d2de30a27c46d835b1351ae69ab8be (01:21): I have table A with partition B.  I have an unpartitioned table C with index CI.",
        "37d2de30a27c46d835b1351ae69ab8be (01:21): I want to exchange B so that the data in C will now be in table A, along with the index CI",
        "37d2de30a27c46d835b1351ae69ab8be (01:21): Q: will CI be a local index?",
        "443a9547033ec9d695ae9d29e8df98b1 (01:22): AQWQ: Can you even do that?",
        "443a9547033ec9d695ae9d29e8df98b1 (01:22): exchange a normal table to a partition table that is",
        "319d0a1e326931a783368784eda07f5b (01:23): back from the dead",
        "37d2de30a27c46d835b1351ae69ab8be (01:23): isn't that the whole point of partition exchange",
        "443a9547033ec9d695ae9d29e8df98b1 (01:23): no",
        "37d2de30a27c46d835b1351ae69ab8be (01:23): every use case I've seen does just that",
        "443a9547033ec9d695ae9d29e8df98b1 (01:24): the point is to exchange from one paritioned table to another",
        "37d2de30a27c46d835b1351ae69ab8be (01:24): especially for data loading",
        "37d2de30a27c46d835b1351ae69ab8be (01:24): I've actually only seen partition &lt;-&gt; table swaps",
        "443a9547033ec9d695ae9d29e8df98b1 (01:24): i've never echanged from an unpartitioned table... may be possible",
        "443a9547033ec9d695ae9d29e8df98b1 (01:24): exchanged*",
        "37d2de30a27c46d835b1351ae69ab8be (01:25): <a href=\"http://www.psoug.org/reference/partitions.html\">http://www.psoug.org/reference/partitions.html</a>",
        "37d2de30a27c46d835b1351ae69ab8be (01:25): &quot;Convert A Partition Into A Stand-alone Table&quot;",
        "37d2de30a27c46d835b1351ae69ab8be (01:25): tkyte even recommends doing it to get around NOLOGGING overhead",
        "443a9547033ec9d695ae9d29e8df98b1 (01:25): yes, thats backwards right",
        "443a9547033ec9d695ae9d29e8df98b1 (01:25): can  you do it from unpartitioned table to a partition?",
        "37d2de30a27c46d835b1351ae69ab8be (01:25): hali: ? it is the same thing",
        "443a9547033ec9d695ae9d29e8df98b1 (01:26): no",
        "37d2de30a27c46d835b1351ae69ab8be (01:26): you are exchange the objects",
        "37d2de30a27c46d835b1351ae69ab8be (01:26): what was in one is now in the other, and vice versa",
        "37d2de30a27c46d835b1351ae69ab8be (01:28): <a href=\"http://www.dbspecialists.com/presentations/load_faster.html\">http://www.dbspecialists.com/presentations/load_faster.html</a>  see &quot;Partition Exchange&quot;",
        "37d2de30a27c46d835b1351ae69ab8be (01:29): load data into a new unpartitioned table, then swap into your regular table",
        "37d2de30a27c46d835b1351ae69ab8be (01:29): new table would be NOLOGGING.  you also build the indexes on new table and include those when swapping",
        "37d2de30a27c46d835b1351ae69ab8be (01:29): this basically means existing table isn't negatively affected while you are loading, and then the new data is avaialble almost instantly",
        "443a9547033ec9d695ae9d29e8df98b1 (01:35): i was under the impression the loading table need to have a partition",
        "443a9547033ec9d695ae9d29e8df98b1 (01:35): in order to get the range/hash/list right",
        "443a9547033ec9d695ae9d29e8df98b1 (01:37): from what i can see from the syntax of exchange partition you need to specify the partition name to exchange",
        "443a9547033ec9d695ae9d29e8df98b1 (01:37): hence it needs to &quot;exist&quot;",
        "37d2de30a27c46d835b1351ae69ab8be (01:44): you specify one partition and one table",
        "37d2de30a27c46d835b1351ae69ab8be (01:44): you swap the entire table into the one partition, and vice versa",
        "37d2de30a27c46d835b1351ae69ab8be (01:44): it basically just changes pointers",
        "443a9547033ec9d695ae9d29e8df98b1 (01:46): you are probably right",
        "443a9547033ec9d695ae9d29e8df98b1 (01:47): c/probably//",
        "443a9547033ec9d695ae9d29e8df98b1 (01:47): did a small test",
        "443a9547033ec9d695ae9d29e8df98b1 (01:47): it works fine",
        "37d2de30a27c46d835b1351ae69ab8be (01:49): \\o/",
        "443a9547033ec9d695ae9d29e8df98b1 (01:49): as long as there is an empty parition of course..",
        "443a9547033ec9d695ae9d29e8df98b1 (01:49): partition*",
        "443a9547033ec9d695ae9d29e8df98b1 (01:52): Solaris, Oracle EE and the worlds most advanced file system... on a laptop.. who would have thought that was possible 3 years ago :)",
        "443a9547033ec9d695ae9d29e8df98b1 (01:52): i'm so pleased wit the latest solaris nevada release... damn fast to boot up",
        "443a9547033ec9d695ae9d29e8df98b1 (01:52): and 10gr2 is ok although it's only got 768megs of ram",
        "37d2de30a27c46d835b1351ae69ab8be (01:53): hali: yeah it wouldn't make sense if the partition weren't empty",
        "37d2de30a27c46d835b1351ae69ab8be (01:53): unless your new table duplicated that data",
        "443a9547033ec9d695ae9d29e8df98b1 (01:53): and the data must match the partition",
        "37d2de30a27c46d835b1351ae69ab8be (01:53): hali: don't suppose you tested with indexes?",
        "37d2de30a27c46d835b1351ae69ab8be (01:54): yep",
        "443a9547033ec9d695ae9d29e8df98b1 (01:54): with indexes;",
        "443a9547033ec9d695ae9d29e8df98b1 (01:54): and it works",
        "443a9547033ec9d695ae9d29e8df98b1 (01:54): at last for local indexes",
        "443a9547033ec9d695ae9d29e8df98b1 (01:54): if you have a global index and specify with indexes you get an error i would guess..",
        "443a9547033ec9d695ae9d29e8df98b1 (01:56): im back to my hifi shopping browsing :)",
        "37d2de30a27c46d835b1351ae69ab8be (01:56): hali: so the partitioned table has to be created with local indexes before hand",
        "37d2de30a27c46d835b1351ae69ab8be (01:57): I assume the other table would just have a 'normal' index",
        "443a9547033ec9d695ae9d29e8df98b1 (01:57): unless you have a global index.. then that index would be updated during the exchange.. hence taking much longer",
        "443a9547033ec9d695ae9d29e8df98b1 (01:57): but it's more expensive to scan a number of local indexes",
        "37d2de30a27c46d835b1351ae69ab8be (01:58): but global indexes break during loads :p",
        "37d2de30a27c46d835b1351ae69ab8be (01:58): they are teh debil",
        "443a9547033ec9d695ae9d29e8df98b1 (01:58): so it may be worth having the global index ... if your queries need to scan a lot of partitions",
        "443a9547033ec9d695ae9d29e8df98b1 (01:58): which they shouldn't",
        "443a9547033ec9d695ae9d29e8df98b1 (01:59): and yes",
        "443a9547033ec9d695ae9d29e8df98b1 (01:59): avoid global indexes if you can",
        "443a9547033ec9d695ae9d29e8df98b1 (02:02): global indexes use more space as well",
        "443a9547033ec9d695ae9d29e8df98b1 (02:06): i need to pickup a good dw book"
    ],
    "person_ids": [
        "37d2de30a27c46d835b1351ae69ab8be",
        "443a9547033ec9d695ae9d29e8df98b1",
        "319d0a1e326931a783368784eda07f5b"
    ]
}