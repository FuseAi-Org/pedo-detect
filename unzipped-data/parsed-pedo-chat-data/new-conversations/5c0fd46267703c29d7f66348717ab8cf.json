{
    "id": "5c0fd46267703c29d7f66348717ab8cf",
    "messages": [
        "042dd99eb0ff8653814e445ca0093427 (03:15): I need to add an API to extract a MediaStream from an HTML media element",
        "042dd99eb0ff8653814e445ca0093427 (03:16): I have to decide whether the stream should represent &quot;whatever's currently playing in the media element&quot; or &quot;just the current resource, until it ends&quot;",
        "042dd99eb0ff8653814e445ca0093427 (03:17): in the latter case, loading a new resource or restarting playback after &quot;ended&quot; would start a new stream",
        "042dd99eb0ff8653814e445ca0093427 (03:17): 69b0d3dfe919a6b860a9fac82de52a7e: any opinion?",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:17): hmm",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:17): what's the use case?",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:17): pushing to a peer / WebAudio processing?",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:17): or saving the resource to disk?",
        "042dd99eb0ff8653814e445ca0093427 (03:17): those are all use-cases",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:18): displaying it in a monitor &lt;video&gt;?",
        "042dd99eb0ff8653814e445ca0093427 (03:18): the latter is less interesting I think",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:18): if the use case is to take whatever the user is currently watching and essentially fork it for use elsewhere, i'd go with having a &quot;live&quot; copy that just streams whatever is being rendered",
        "042dd99eb0ff8653814e445ca0093427 (03:18): my main use cases are audio/video playback with mixing and processing; stream it out to a peer is a secondary use-case",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:18): so e.g. it would start displaying a static image if the media element was paused, etc",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:19): though that would act really weird if you then could pause and rewind it",
        "042dd99eb0ff8653814e445ca0093427 (03:19): the main problem with the &quot;whatever's currently playing&quot; approach is that it means the stream can end, and then start producing data again later",
        "042dd99eb0ff8653814e445ca0093427 (03:19): the RTC people don't like that",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:19): why would it end?",
        "042dd99eb0ff8653814e445ca0093427 (03:20): if you treat the &quot;ended&quot; state of the media element as ending the stream",
        "042dd99eb0ff8653814e445ca0093427 (03:20): which would be intuitively appealing, and useful as well",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:21): if you're just outputting what the media element is playing, i don't think you'd do that",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:22): &quot;ended&quot; just means that the current playback position is at the end",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:22): doesn't mean that there won't be more later",
        "042dd99eb0ff8653814e445ca0093427 (03:22): then we'd need a different API to let authors load a media resource and get a MediaStream for it that ends when the resource ends",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:23): well, i could certainly see a use case for &quot;get a mediastream for a resource&quot;, but it wouldn't &quot;end&quot;, it would just represent the (possibly finite) resource, right?",
        "042dd99eb0ff8653814e445ca0093427 (03:23): we could have both APIs on the media element, but that might be confusing",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:24): i guess it would &quot;end&quot; when the whole resource was obtained",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:24): which might be immediately if the resource is cached",
        "042dd99eb0ff8653814e445ca0093427 (03:24): MediaStreams end when they will no longer produce any new data",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:25): right",
        "042dd99eb0ff8653814e445ca0093427 (03:25): the MediaStream for a resource ends when we've finished playing it back",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:25): so a MediaStream of a finite resource that happens to be already cached would end immediately after providing all the data to whatever consumer exists",
        "042dd99eb0ff8653814e445ca0093427 (03:25): MediaStreams play back in real time, they can't instantly deliver all their data to some consumer",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:26): oh",
        "042dd99eb0ff8653814e445ca0093427 (03:26): at least, the way I understand it",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:26): well then it doesn't make much sense to get one for a static resource",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:26): surely",
        "042dd99eb0ff8653814e445ca0093427 (03:26): sure it does",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:26): what if the user wants to fast-forward?",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:27): it'd be really weird to tell the user that he can pause, rewind, etc, but he can't fast-forward ahead of where the mediastream happens to have reached",
        "042dd99eb0ff8653814e445ca0093427 (03:27): you can't fast-forward a MediaStream",
        "042dd99eb0ff8653814e445ca0093427 (03:27): you can pause, but not rewind",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:27): especially if the user just gave you the File in question",
        "042dd99eb0ff8653814e445ca0093427 (03:28): if the user just gave you a File then you can make a BlobURL and just play that",
        "042dd99eb0ff8653814e445ca0093427 (03:28): MediaStreams need not be involved",
        "042dd99eb0ff8653814e445ca0093427 (03:28): and then you can do everything",
        "042dd99eb0ff8653814e445ca0093427 (03:29): defining a media processing graph where you can control the playback rate of individual streams gets very problematic",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:29): well to answer your original question, i think if mediastream represents live data and only live data, and you create one from an HTMLMediaElement, it should represent whatever frame/audio is currently playing",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:29): and it shouldn't ever &quot;end&quot;",
        "042dd99eb0ff8653814e445ca0093427 (03:30): (you end up being able to consume a single stream at different rates, and therefore at different time offsets, which is not really implementable)",
        "042dd99eb0ff8653814e445ca0093427 (03:30): ok",
        "042dd99eb0ff8653814e445ca0093427 (03:31): then we'll need a separate API to create a MediaStream for a resource that ends when the resource playback ends",
        "042dd99eb0ff8653814e445ca0093427 (03:31): any suggestions on where that should lvie?",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:31): what's the use case for that one?",
        "042dd99eb0ff8653814e445ca0093427 (03:31): because if it doesn't live on the media element, then we have to duplicate all the source selection logic and probably more, which would really suck",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:32): why wouldn't you just create an HTMLMediaElement that the user can't mess with, and use that to feed the MediaStream?",
        "042dd99eb0ff8653814e445ca0093427 (03:32): I can do that I guess",
        "042dd99eb0ff8653814e445ca0093427 (03:32): then I have to add an API somewhere to forcibly end the stream",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:33): MediaStream.end()",
        "042dd99eb0ff8653814e445ca0093427 (03:33): people want to add features that trigger when streams end",
        "042dd99eb0ff8653814e445ca0093427 (03:33): OK",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:33): if it's the kind of feature where precise timing matters, i guess you could just create a MediaStream from a fixed URL, and screw the source selection stuff",
        "042dd99eb0ff8653814e445ca0093427 (03:34): precise timing is not really an issue",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:34): if someone needs to pick a source, they can create a &lt;video&gt; and have it do the source selection and then use the result from that",
        "042dd99eb0ff8653814e445ca0093427 (03:34): that's a bit ugly",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:34): not the most efficient, certainly",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:34): what kind of thing are we triggering on end?",
        "1f8387eb43f131d7c309a90a4e36b5cb (03:35): Hmm.  &lt;http://jsfiddle.net/leaverou/e77P2/&gt; shows a style element being disabled, and then it gets automatically reenabled when you set .textContent on it.  Is that supposed to happen?",
        "042dd99eb0ff8653814e445ca0093427 (03:35): disconnecting the stream from downstream mixers, for example",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:35): 042dd99eb0ff8653814e445ca0093427: oh if it's just cleanup then yeah, i'd go with an explicit .end().",
        "69b0d3dfe919a6b860a9fac82de52a7e (03:35): ok i gotta go, bbl",
        "042dd99eb0ff8653814e445ca0093427 (03:35): ta"
    ],
    "person_ids": [
        "042dd99eb0ff8653814e445ca0093427",
        "69b0d3dfe919a6b860a9fac82de52a7e",
        "1f8387eb43f131d7c309a90a4e36b5cb"
    ]
}