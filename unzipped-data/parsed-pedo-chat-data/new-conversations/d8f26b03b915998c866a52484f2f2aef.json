{
    "id": "d8f26b03b915998c866a52484f2f2aef",
    "messages": [
        "b8810fee2f4a71f849f3f7409546d1d9 (13:44): btw, I'm finding that the tokenizer can easily be implemented as a recursive descent tokenizer without an explicit state variable",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:45): wrapper loops are needed for attributes and the data state to avoid arbitrarily deep recursion",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:46): buffering?",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:46): oh, you're doing SAX",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:46): 73c8ec97fe210f482d81a5f04e5e6642: I intend to do SAX with and without buffering, DOM and XOM",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:46): so the recursion is just for eg. see a '&lt;', call parseStartTag() ?",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:46): 73c8ec97fe210f482d81a5f04e5e6642: this is the Tokenizer only",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:47): nods",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:47): 73c8ec97fe210f482d81a5f04e5e6642: yes",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:47): so if you don't use arbitrary recursion, technically you don't need to recurse at all, right?",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:47): if you introduce new states...",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:47): and allow it to start in arbitrary states",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:47): you could just jump around inside a big single function",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:48): 73c8ec97fe210f482d81a5f04e5e6642: well, to avoid stack overflow regardless of input, I have a loop around the attribute states so that the stack rewinds back to the loop between attributes",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:49): right, eg. while getAttribute() ...",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:49): yes",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:49): but you don't actually need recursive calls, if you're not parsing a recursive grammar",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:49): it's just for convenience structuring your code, yes?",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:49): this is for code structuring, yes",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:50): also, I am assuming that a straight final method invocation in Java is going to be faster than state lookup plus method dispatch",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:50): hmm, Java has no goto, right? :)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:51): 73c8ec97fe210f482d81a5f04e5e6642: no goto in .java level",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:51): right",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:51): sounds pretty good then :)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:51): 73c8ec97fe210f482d81a5f04e5e6642: my reasoning is that this is as good as it gets without goto and jump arithmetic based on input token",
        "65325d50b2e25aca54bc871b89758c9c (13:51): the way to code a state machine is a loop with a switch statement",
        "65325d50b2e25aca54bc871b89758c9c (13:52): not via dynamic method dispatch",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:52): s/the way/a way/ :)",
        "65325d50b2e25aca54bc871b89758c9c (13:52): the efficient way",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:53): 65325d50b2e25aca54bc871b89758c9c: you get as many method invocations either way, right?",
        "65325d50b2e25aca54bc871b89758c9c (13:53): b8810fee2f4a71f849f3f7409546d1d9: well, I'm not sure why you contrasted &quot;static final method invocation&quot; with the other option",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:54): straight--not static",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:54): 65325d50b2e25aca54bc871b89758c9c: if you have one method per state",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:55): 65325d50b2e25aca54bc871b89758c9c: and state B follows A, why would I return to a dispatch loop in between?",
        "65325d50b2e25aca54bc871b89758c9c (13:55): depends on whether function calls are more expensive in your language than conditional branches",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:56): 65325d50b2e25aca54bc871b89758c9c: ah, you are assuming that I could do away with function calls",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:56): 65325d50b2e25aca54bc871b89758c9c: I am assuming one method per state either way for code structuring sanity",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:56): (since this is human-maintained code--not generated code)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:56): I'm hoping the HotSpot does some inlining",
        "65325d50b2e25aca54bc871b89758c9c (13:57): well, with the switch, the compiler and/or the Java runtime can definitely inline everything into the switch statement",
        "73c8ec97fe210f482d81a5f04e5e6642 (13:57): I guess a parsing DSL that compiled down to Java byte code could help",
        "65325d50b2e25aca54bc871b89758c9c (13:57): if each processing method is final and they don't call each other",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:57): 65325d50b2e25aca54bc871b89758c9c: good point",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:57): 65325d50b2e25aca54bc871b89758c9c: thanks",
        "65325d50b2e25aca54bc871b89758c9c (13:58): anyway I don't know which way would be faster in Java",
        "65325d50b2e25aca54bc871b89758c9c (13:58): I don't have a lot of experience performance-tuning Java code",
        "65325d50b2e25aca54bc871b89758c9c (13:58): (though I do have performance-tuning experience in general)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:58): yeah, this is guesswork without either benchmarking or knowing what HotSpot inlines",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:59): ok. I'll convert to a switch that is potentially inlineable",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:00): a bit of premature optimisation going on here perhaps :)",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:00): by the way, have you done meta charset detection yet?",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:00): 73c8ec97fe210f482d81a5f04e5e6642: written--not run",
        "65325d50b2e25aca54bc871b89758c9c (14:00): depends on whether b8810fee2f4a71f849f3f7409546d1d9 finds it easier to code a finite state machine or a recursive descent parser",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:01): hmm, I better hurry up then, I've been dragging my feet over it",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:01): 73c8ec97fe210f482d81a5f04e5e6642: in C?",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:01): yes",
        "65325d50b2e25aca54bc871b89758c9c (14:02): 73c8ec97fe210f482d81a5f04e5e6642: you're writing an HTML5 parser in C?",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:02): yes, that's why I come here, to make me feel guilty enough to work on it some more",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:02): hmm. come to think of it, I still think the way I have coded this is potentially a bit more efficient if HotSpot does deep inlines",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:03): perhaps I leave the optimization for later after all",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:04): a collegue did some testing on tokenization in C/C++ versus Python and JavaScript",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:04): C: ~1ms, Python: ~100ms, JavaScript: ~500ms",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:04): lucky no one is writing a parser in JavaScript I guess",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:04): ...or ARE they",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:05): edb259c0e0038f38bb200bc20c8cbf7e: I would expect buffering to matter a lot in that case (and string object creation)",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:05): I guess you could use a dictionary and avoid creating new string objects where possible",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:05): eg. precache tag names and attribute names",
        "65325d50b2e25aca54bc871b89758c9c (14:07): which JavaScript implementation?",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:07): 73c8ec97fe210f482d81a5f04e5e6642: how do you look at a character in Python or JS without creating a string object?",
        "65325d50b2e25aca54bc871b89758c9c (14:07): JavaScript suffers from the boxed/unboxed distinction for strings there I guess",
        "65325d50b2e25aca54bc871b89758c9c (14:07): if you actually use string methods",
        "ab7faae5d7b250ea8606486575f8f79c (14:08): HotSpot should be happy with inlining methods even when they're not final or are potentially recursive",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:08): b8810fee2f4a71f849f3f7409546d1d9, buffer file to array of int instead?",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:09): ab7faae5d7b250ea8606486575f8f79c: these are final and to a finite recursion depth",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:09): 73c8ec97fe210f482d81a5f04e5e6642: ok",
        "65325d50b2e25aca54bc871b89758c9c (14:09): array of int is much less efficient than a string in JS",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:09): 65325d50b2e25aca54bc871b89758c9c, string methods were used, Opera 9.2 was used for testing I think",
        "ab7faae5d7b250ea8606486575f8f79c (14:09): (e.g. http://java.sun.com/developer/technicalArticles/Networking/HotSpot/inlining.html (from 1999) talks about inlining non-final methods, and it just remembers enough to undo the optimisation if its assumptions are ever violated)",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:10): Python is already a hundred times slower...",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:10): how about Ruby? :)",
        "65325d50b2e25aca54bc871b89758c9c (14:10): it's hard to beat C",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:10): We really need a C implementation if we want to use it for surveys and such",
        "65325d50b2e25aca54bc871b89758c9c (14:10): except sometimes with C++",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:10): surveys?",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:10): Well, surveys covering lots of pages...",
        "65325d50b2e25aca54bc871b89758c9c (14:10): if I were doing it I would use C++",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:10): bleh.",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:11): 73c8ec97fe210f482d81a5f04e5e6642, like the research Ian did",
        "ab7faae5d7b250ea8606486575f8f79c (14:11): Even with a thousand pages, the Python one is unpleasantly slow :-(",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:11): oh, right",
        "65325d50b2e25aca54bc871b89758c9c (14:11): and probably at least two open source HTML5 parsers will be written in C++ sooner or later",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:11): wonders how hard the browser parsers are to extract",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:11): IIRC, HotSpot beats C for some problems",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:11): will be interesting to see if this is one of them :-)",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:12): Java beats C for malloc()",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:12): so... don't use malloc :)",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:12): :-)",
        "65325d50b2e25aca54bc871b89758c9c (14:13): edb259c0e0038f38bb200bc20c8cbf7e: our current HTML parser does the DOM building, so probably not that easily separable",
        "ab7faae5d7b250ea8606486575f8f79c (14:13): C always wins because you can implement a JVM in it :-)",
        "edb259c0e0038f38bb200bc20c8cbf7e (14:14): 65325d50b2e25aca54bc871b89758c9c, that's what I thought, main reason why I think having a third would be good",
        "65325d50b2e25aca54bc871b89758c9c (14:15): having a standalone one would be nice, it it was packaged well",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:16): indeed.",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:17): yay, testhtml is parsing attribute names and getting &quot;http-equiv&quot;",
        "65325d50b2e25aca54bc871b89758c9c (14:18): if I were doing it for fun, I'd do C++ implementation, C API",
        "65325d50b2e25aca54bc871b89758c9c (14:18): but if I have hobby coding time it will probably be spent on WebKit hacking",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:19): hmm, not getting attribute values though. That's slightly useless.",
        "b8810fee2f4a71f849f3f7409546d1d9 (14:20): (fwiw, recursive call to a finite depth with loops in the right places seems to be how others have written XML parsers in Java)",
        "73c8ec97fe210f482d81a5f04e5e6642 (14:20): that's also how libxml2 is written I think"
    ],
    "person_ids": [
        "b8810fee2f4a71f849f3f7409546d1d9",
        "73c8ec97fe210f482d81a5f04e5e6642",
        "edb259c0e0038f38bb200bc20c8cbf7e",
        "65325d50b2e25aca54bc871b89758c9c",
        "ab7faae5d7b250ea8606486575f8f79c"
    ]
}