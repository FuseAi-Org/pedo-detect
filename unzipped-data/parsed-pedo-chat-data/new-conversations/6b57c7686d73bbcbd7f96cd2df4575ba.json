{
    "id": "6b57c7686d73bbcbd7f96cd2df4575ba",
    "messages": [
        "f139aba52f9fa1394b4034a7954b2220 (12:04): 69b0d3dfe919a6b860a9fac82de52a7e, yt?",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:07): 73eaf221abca1b8244e34b0b9e76ac46, http://simon.html5.org/temp/html5lib-tests/dom2string.js doesn't seem to handle attributes",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:08): edb259c0e0038f38bb200bc20c8cbf7e: oops",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:13): edb259c0e0038f38bb200bc20c8cbf7e: fixed",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:18): f139aba52f9fa1394b4034a7954b2220: yo",
        "f139aba52f9fa1394b4034a7954b2220 (12:19): Hey 69b0d3dfe919a6b860a9fac82de52a7e, Marcos and I are working on the XBL Primer, and we're trying to come up with a concise description of what a template is.  Any suggestions?",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:20): it's some markup that will be used to render the bound element, i guess",
        "f139aba52f9fa1394b4034a7954b2220 (12:20): so far we have &quot;A template is used to control the presentation of a document&quot;, but we want to say something about how it reorders content in the DOM, without altering it, using shadow trees, but without using technical terms",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:20): interesting, Opera returns uppercase attribute names",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:21): edb259c0e0038f38bb200bc20c8cbf7e: yeah.",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:21): f139aba52f9fa1394b4034a7954b2220: good luck",
        "f139aba52f9fa1394b4034a7954b2220 (12:21): thanks",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:21): f139aba52f9fa1394b4034a7954b2220: my best attempt is what's in the spec",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:21): f139aba52f9fa1394b4034a7954b2220: in the note in the definition of &lt;template&gt;",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:22): &quot;A template defines the building blocks for the subtree of the bounding element.&quot;",
        "f139aba52f9fa1394b4034a7954b2220 (12:22): yeah, that's the problem :-)",
        "f139aba52f9fa1394b4034a7954b2220 (12:23): hmm. we could try and work something like that into it.",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:24): just say something and then illustrate it with some &quot;easy&quot; to grasp examples",
        "f139aba52f9fa1394b4034a7954b2220 (12:24): yeah, that's the idea",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:27): hm. opera can have cdata nodes in the dom. how should i output those?",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:27): &quot;&lt;![CDATA[ &quot; + current.nodeValue + &quot; ]]&gt;&quot; ?",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:29): yeah",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:32): done",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:38): i'm instrumenting my html parser to report how many times it clones nodes in the AAA and inline-reconstruction algorithms",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:38): anything else i can instrument while i'm at it?",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:39): b8810fee2f4a71f849f3f7409546d1d9? edb259c0e0038f38bb200bc20c8cbf7e? jgraham?",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:40): we have some XXX comments about tokenization...",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:41): specifically which cases in states are the most frequent",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:41): so you can optimize those cases in some way...",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:42): other interesting things might be &lt;form&gt; nodes &lt;form&gt; where nodes does not include &lt;/form&gt; and then do some browser testing on those more complicated examples from real world pages",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:44): eh?",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:45): i could emit for each tokeniser state the most common tokens seen, i guess",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:46): it would make the parser way slower, but it could work",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:46): it's probably not very important",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:46): tree mutation and node duplication are more interesting",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:47): would be fun to count how often you encounter &lt;canvas&gt; nowadays :)",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:49): i've looked at elements in a separate study",
        "69b0d3dfe919a6b860a9fac82de52a7e (12:50): canvas didn't appear in the top 200",
        "73eaf221abca1b8244e34b0b9e76ac46 (12:51): suspects that some &lt;canvas&gt;es are only output with script",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:00): k",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:00): hmm. dom core doesn't specify an order for .attributes ... i need to sort them myself",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:01): I wonder if we have actually sorted them...",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:03): opera and safari don't seem to sort them. ie seems to sort them alphabetically. firefox alphabetically reversed.",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:03): ok i'm going to emit a list of total count of all the tokens",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:04): for each kind of token in each insertion mode",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:04): anything else?",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:04): last chance before i set this off and go to bed...",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:04): ah, I actually meant characters I think",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:04): but that may be too expensive",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:04): characters?",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:04): during tokenization",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:04): how do you mean?",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:05): see how often &quot;&gt;&quot; (with quotes) appears in doctypes or bogus comments",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:05): so you can optimize a particular tokenization state",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:05): oh i thought you wanted to optimise the tree constructor states",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:06): 73eaf221abca1b8244e34b0b9e76ac46: hm",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:06): 69b0d3dfe919a6b860a9fac82de52a7e: hmm. I guess there might be merit in instrumenting how often IN_BODY code runs with the actual insertion mode being one of the table modes other than caption and cell",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:06): edb259c0e0038f38bb200bc20c8cbf7e: surely for the tokeniser it makes no difference since you'll just do table dispatch",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:06): IE has this nice &lt;!- .... &quot;&gt;&quot; more comment ... &gt;",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:07): 69b0d3dfe919a6b860a9fac82de52a7e: http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2007-June/012078.html",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:07): b8810fee2f4a71f849f3f7409546d1d9: you mean an average of times per page that the inbody state is invoked when the state is not inbody, incell, or incaption?",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:07): 69b0d3dfe919a6b860a9fac82de52a7e: is it even important to clone DOM nodes instead of using the attributes on the original token and creating a new DOM node using those?",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:07): 73eaf221abca1b8244e34b0b9e76ac46: yeah i'm just trying to work out how to do it",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:07): that is, do you really want to close concurrent attribute changes?",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:08): i don't think the dom supports having attributes shared between nodes",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:09): 69b0d3dfe919a6b860a9fac82de52a7e: yes, the average times the table states actually fall though to in body",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:09): through",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:12): ok, i'm logging the actual insertion mode when my inhead, inbody, and intable functions are invoked",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:12): 69b0d3dfe919a6b860a9fac82de52a7e: since that only happens in non-conforming cases and Java doesn't have goto, I let the code hit some useless branches when the fall-through happens",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:12): hopefully they map exactly to the spec",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:14): 73eaf221abca1b8244e34b0b9e76ac46: for DOCTYPEs we don't care, right? since what the spec does matches IE anyway?",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:14): (A smart compiler could fix this, but I doubt javac or hotspot are that smart)",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:14): yeah, DOCTYPEs match IE",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:14): it's just that IE uses the same mode for bogus comments as they use for DOCTYPEs it seems",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:15): i'm gonna bail on working out what characters are most common in each tokeniser mode, on the principle that there are so few states it hardly matters anyway",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:15): 69b0d3dfe919a6b860a9fac82de52a7e: not quite. the spec doesn't handle &lt;!doctype &quot;&gt;&quot; &gt;",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:15): oops",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:15): 69b0d3dfe919a6b860a9fac82de52a7e: the spec only matches ie if the &gt; is in an actual FPI or SPI",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:16): 69b0d3dfe919a6b860a9fac82de52a7e: oh yeah, one more thing for optimization: whether an average stack node is tested for being in a group of element names more than once",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:17): well i didn't find any DOCTYPEs with &gt; in their name part, at least not enough to appear on my radar in the scan of doctypes i did earlier this week",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:17): 69b0d3dfe919a6b860a9fac82de52a7e: that is, whether it makes sense to have a boolean on a stack node that says for example whether the node is a table context sentinel",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:17): 69b0d3dfe919a6b860a9fac82de52a7e: ok",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:17): 69b0d3dfe919a6b860a9fac82de52a7e: isn't that because &gt; in the name part terminates the doctype? :)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:18): 69b0d3dfe919a6b860a9fac82de52a7e: or whether a stack node should have a flag for phrasing OR formatting OR div OR address",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:18): sorry, i meant &quot;",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:18): ah",
        "73eaf221abca1b8244e34b0b9e76ac46 (13:18): ok",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:18): b8810fee2f4a71f849f3f7409546d1d9: so what i did with that is that each well-known tag name has an integer associated with it (like an atom) and for each special feature that the parser cares about i used a bit",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:19): i used 24 bits for these flags",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:20): so for example all the &lt;hx&gt; elements have the number 0x400008400000",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:20): 69b0d3dfe919a6b860a9fac82de52a7e: my strategy is to intern well-known names so that testing against one name is a comparison of memory addresses but still testing if a name is in a group means as many comparisons as names names in group",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:20): the leading 0x4 is &quot;element&quot; (as opposed to text node), the 8 is &quot;hx node&quot;, and the 4 is &quot;closes &lt;p&gt; elements&quot;",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:21): yeah so my parser never compares tag names once they're in the stack",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:21): doing string compares was prohibitively expensive",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:21): interesting",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:21): i just use the integer that says whether a node is a text node, comment node, doctype, etc, to say what special kind of element it is too",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:22): and so everything is always exactly one &amp; and exactly one ==",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:23): and you construct those numbers during tokenization?",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:23): I guess I'll complete the tree builder with my current approach and will leave a tokenizer-assigned bitfield as a later interface-breaking optimization",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:24): edb259c0e0038f38bb200bc20c8cbf7e: whenever i create a node, i create it withe the appropriate constant",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:24): the tokeniser doesn't know about these",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:24): it emits tokens with tag names",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:24): it's only when i create nodes that i use these",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:24): 69b0d3dfe919a6b860a9fac82de52a7e: ooh. so &quot;closes p&quot; is not assigned in the tokenizer after all",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:24): ok, so the tree construction stage does use string comparison?",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:25): yeah, tokens are string-compared",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:25): but i think my compiler might be atomising them",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:25): so it's not such a big deal",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:27): I'm currently using the generic String.intern(), but I figured how to make a fast interning function with knowledge about the possible names (three-level switch: length, last char, second to last char)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:27): but typing that is too much work",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:27): so I guess I'll write a small Python program that generates Java code for the interning function at some point",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:28): 73eaf221abca1b8244e34b0b9e76ac46: given that only IE does this, I'm going to assume it's not a big deal. I can investigate it in more detail later maybe. Don't want to hack the parser too much tonight. :-)",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:28): beware that the names are unbounded",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:28): &lt;fiv&gt; is an element name that is seen in the wild, e.g.",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:28): you don't want to treat it as &lt;div&gt;",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:29): especially in your case :-)",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:30): 69b0d3dfe919a6b860a9fac82de52a7e: of if the length is &gt; 2, the prefix needs to be compared, too, to make sure",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:30): 69b0d3dfe919a6b860a9fac82de52a7e: still better than an intermediate copy to java.lang.String",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:31): 69b0d3dfe919a6b860a9fac82de52a7e: the idea is to weed out all but one prefix candidate",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:31): ah cool",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:36): right sleep time",
        "69b0d3dfe919a6b860a9fac82de52a7e (13:36): nn",
        "b8810fee2f4a71f849f3f7409546d1d9 (13:36): nn"
    ],
    "person_ids": [
        "f139aba52f9fa1394b4034a7954b2220",
        "edb259c0e0038f38bb200bc20c8cbf7e",
        "73eaf221abca1b8244e34b0b9e76ac46",
        "69b0d3dfe919a6b860a9fac82de52a7e",
        "b8810fee2f4a71f849f3f7409546d1d9"
    ]
}