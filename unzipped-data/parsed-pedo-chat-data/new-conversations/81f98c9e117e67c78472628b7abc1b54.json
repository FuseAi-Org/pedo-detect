{
    "id": "81f98c9e117e67c78472628b7abc1b54",
    "messages": [
        "f4ea20ae05d2da565e774193265e2df2 (23:44): NIXN00b: what defines a neighbor pair? is it just a matter of the vicinity to the sequence you match?",
        "d62afdc9204c79741b4257d04c5a2a1e (23:44): NIXN00b: and the result you are looking for is...?",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:45): paavo: err, well I meant to say each pair has an associated value or penalty. AT=1 AA=1.4 AC=1.8 AG=2.1, and etc for all possible combinations. There are four possible bases, A, T, G, C and you can at most two at a time.",
        "10120f397a0f4db70d1aeb2d81229e70 (23:46): ironfroggy: help(os.path.split)",
        "d62afdc9204c79741b4257d04c5a2a1e (23:46): NIXN00b: and what do you want to do with those penalties? add them all up for the entire sequence?",
        "c24781797c98640feb74dfa85104daaf (23:46): NIXN00b: have you read <a href=\"http://www.onlamp.com/pub/a/python/2002/10/17/biopython.html\">http://www.onlamp.com/pub/a/python/2002/10/17/biopython.html</a> ?",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:46): ironfroggy: the sequence is linear so you assume that what basically happens is the first pair is the AT, the next TG and so on.",
        "f4ea20ae05d2da565e774193265e2df2 (23:46): ChrisLong: was i thinking it was more like str.split than it is?",
        "f4ea20ae05d2da565e774193265e2df2 (23:46): NIXN00b: still seems like you want the str.find method to locate them.",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:47): tp76: the biopython project is all fine and good but I want to reinvent the wheel for my own purposes. Thanks though, I'll have a look at the article.",
        "10120f397a0f4db70d1aeb2d81229e70 (23:47): ironfroggy: yes, you were.from the doc: Returns tuple &quot;(head, tail)&quot; where &quot;tail&quot; is everything after the final slash",
        "f4ea20ae05d2da565e774193265e2df2 (23:47): [dna[i]+dna[i+1] for i in len(dna[dna.find(sequence):len(sequence)]) ]",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:47): ironfroggy: okay, so is that faster than reading through the list then?",
        "f4ea20ae05d2da565e774193265e2df2 (23:48): yes",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:48): ironfroggy: thanks, I'll give that a try",
        "50c232bc2c82a201cecf95533418d3a6 (23:49): I just installed rdiff-backup, and when I call it I get the error message &quot;ImportError: No module named rdiff_backup.Main&quot;.",
        "5cec7600b531bd5c43c58005b0f2d30f (23:49): cleaned up some more, updated again",
        "50c232bc2c82a201cecf95533418d3a6 (23:49): How do I let python know that it should look for modules in",
        "50c232bc2c82a201cecf95533418d3a6 (23:49): /usr/local/lib/python2.4/site-packages",
        "50c232bc2c82a201cecf95533418d3a6 (23:49): ?",
        "5cec7600b531bd5c43c58005b0f2d30f (23:49): but we still haven't come close to addressing the memory issue",
        "f59c82d8094b292316998d98cfb6fff7 (23:49): if i have a: class a(b): ... ie a class thats inherited from another class, is b's init function ever called? or do i have to do that manually? or isnt that possible to do?",
        "9175e6e8af5b2ee38c837d3859892ca6 (23:49): feklee: PYTHONPATH",
        "c3acbf41cfbe935254b58cd3d4a70a96 (23:49): ironfroggy: umm, is that a list comprehension?",
        "5cec7600b531bd5c43c58005b0f2d30f (23:50): Mizipzor, you need to call it",
        "f4ea20ae05d2da565e774193265e2df2 (23:50): NIXN00b: yeah but its broken.",
        "f7551900b33180d964c315501279b946 (23:50): Mizipzor, you can do it manually if you want to  Parent.__init__(self, args)",
        "f59c82d8094b292316998d98cfb6fff7 (23:50): polpak, thanks",
        "f59c82d8094b292316998d98cfb6fff7 (23:50): babbitt, thanks to you to",
        "5cec7600b531bd5c43c58005b0f2d30f (23:50): polpak, I thought we were supposed to user super() now?",
        "50c232bc2c82a201cecf95533418d3a6 (23:50): blackdroid_wd: Seems to work.  Thanks!",
        "f7551900b33180d964c315501279b946 (23:50): babbitt, are we?",
        "9175e6e8af5b2ee38c837d3859892ca6 (23:50): babbitt: well",
        "5cec7600b531bd5c43c58005b0f2d30f (23:51): polpak, I'm not sure...I'm used to the old version (what you told Miz)",
        "f59c82d8094b292316998d98cfb6fff7 (23:52): polpak, i get that &quot;NameError: global name 'Parent' is not defined&quot;",
        "f7551900b33180d964c315501279b946 (23:54): Mizipzor, in your case it'd be b.__init__(self,args)",
        "f59c82d8094b292316998d98cfb6fff7 (23:54): polpak, oh! sorry... thanks",
        "f7551900b33180d964c315501279b946 (23:54): Mizipzor, or you can use super() since it's the new thing( since 2.2)",
        "f7551900b33180d964c315501279b946 (23:55): Mizipzor, super(a, self).__init__(self, args)",
        "f59c82d8094b292316998d98cfb6fff7 (23:55): polpak, hmm... i better look that up",
        "f59c82d8094b292316998d98cfb6fff7 (23:57): isnt it in the docs?",
        "f4ea20ae05d2da565e774193265e2df2 (23:59): polpak: you have one self too many there",
        "f4ea20ae05d2da565e774193265e2df2 (00:00): babbitt: you can remove those spurious del statements too"
    ],
    "person_ids": [
        "f4ea20ae05d2da565e774193265e2df2",
        "d62afdc9204c79741b4257d04c5a2a1e",
        "c3acbf41cfbe935254b58cd3d4a70a96",
        "10120f397a0f4db70d1aeb2d81229e70",
        "c24781797c98640feb74dfa85104daaf",
        "50c232bc2c82a201cecf95533418d3a6",
        "5cec7600b531bd5c43c58005b0f2d30f",
        "f59c82d8094b292316998d98cfb6fff7",
        "9175e6e8af5b2ee38c837d3859892ca6",
        "f7551900b33180d964c315501279b946"
    ]
}