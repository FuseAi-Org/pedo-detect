{
    "id": "cd5ca86984eef71fd291a766d50606c5",
    "messages": [
        "cc097e0d7183ae8436e7df709553c8c0 (11:53): f139aba52f9fa1394b4034a7954b2220: in selectors api, using javascript, if resolver returns undefined, is the namespace then the string &quot;undefined&quot;?",
        "cc097e0d7183ae8436e7df709553c8c0 (11:54): f139aba52f9fa1394b4034a7954b2220: it seems cumbersome to have to explicitly return the empty string instead of just not bothering and let it return undefined...",
        "cc097e0d7183ae8436e7df709553c8c0 (11:55): or is undefined in javascript equivalent to no return value?",
        "cc097e0d7183ae8436e7df709553c8c0 (11:57): or hmm, actually, nevermind",
        "cc097e0d7183ae8436e7df709553c8c0 (12:03): f139aba52f9fa1394b4034a7954b2220: anyway, it seems the spec doesn't contain any conformance requirements for documents, and thus, the conforming documents and conforming authoring tools conformance classes can be dropped",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:21): f139aba52f9fa1394b4034a7954b2220, am now",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:23): getElementsByClassName returns a live NodeList btw",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:23): that's a usecase",
        "f139aba52f9fa1394b4034a7954b2220 (12:29): cc097e0d7183ae8436e7df709553c8c0: in JS, undefined == null, and the spec defines how to handle null",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:30): however, it's not === null",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:30): until the binding spec covers this you probably need to handle undefined",
        "f139aba52f9fa1394b4034a7954b2220 (12:31): How can I make it clearer that anything that == null, should be treated as null",
        "cc097e0d7183ae8436e7df709553c8c0 (12:33): passing a prefix that is not in the table will return undefined too",
        "f139aba52f9fa1394b4034a7954b2220 (12:33): cc097e0d7183ae8436e7df709553c8c0: I already dropped conforming authoring tool.  Were you looking at an old revision?",
        "cc097e0d7183ae8436e7df709553c8c0 (12:34): f139aba52f9fa1394b4034a7954b2220: ah. yes.",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): f139aba52f9fa1394b4034a7954b2220: the resolver could be rewritten a bit more elegantly:",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): function resolver(prefix) {",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): return {",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): &quot;xh&quot;: &quot;http://www.w3.org/1999/xhtml&quot;,",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): &quot;svg&quot;: &quot;http://www.w3.org/2000/svg&quot;",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): }[prefix] || &quot;&quot;;",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:34): }",
        "f139aba52f9fa1394b4034a7954b2220 (12:34): I'm not sure if I'll keep &quot;conforming application&quot; in there, that's only there cause there's a few authoring requirements.",
        "cc097e0d7183ae8436e7df709553c8c0 (12:35): given the function above, passing in &quot;foo&quot; as the prefix will return undefined",
        "f139aba52f9fa1394b4034a7954b2220 (12:35): 2d9b4b2e6d678d91f6afbf8a0763a223: yes, it could, but I chose clarity over being a minimalist",
        "2d9b4b2e6d678d91f6afbf8a0763a223 (12:35): cc097e0d7183ae8436e7df709553c8c0: it will return &quot;&quot;",
        "cc097e0d7183ae8436e7df709553c8c0 (12:36): 2d9b4b2e6d678d91f6afbf8a0763a223: oh, right. ok, given a function in the spec will return undefined",
        "f139aba52f9fa1394b4034a7954b2220 (12:36): oh, I see",
        "cc097e0d7183ae8436e7df709553c8c0 (12:37): an unknown prefix should not get the default namespace",
        "cc097e0d7183ae8436e7df709553c8c0 (12:37): it should raise an exception or something",
        "cc097e0d7183ae8436e7df709553c8c0 (12:37): as in css, the ruleset will be dropped",
        "f139aba52f9fa1394b4034a7954b2220 (12:38): hmm. It doesn't look like I handle returning of empty strings for prefixes in a special way.",
        "f139aba52f9fa1394b4034a7954b2220 (12:38): should I?",
        "f139aba52f9fa1394b4034a7954b2220 (12:40): edb259c0e0038f38bb200bc20c8cbf7e: I wanted to ask you about this earlier...",
        "cc097e0d7183ae8436e7df709553c8c0 (12:40): if you wanted to declare e.g. xhtml as being the default namespace, it should be possible to say ...{ if (prefix == &quot;&quot;) return &quot;http://www.w3.org/1999/xhtml&quot;; } right?",
        "f139aba52f9fa1394b4034a7954b2220 (12:41): It currently says &quot;In doing so, user agents may assume that the object implementing the NSResolver  interface (or ECMAScript Function) only relies on scoped variables, doesn't invoke processes outside the object and returns consistent results when its lookupNamespaceURI method is invoked.&quot;",
        "f139aba52f9fa1394b4034a7954b2220 (12:41): in terminology and conventions http://dev.w3.org/cvsweb/~checkout~/2006/webapi/selectors-api/Overview.html?content-type=text/html;%20charset=utf-8#terminology",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:41): hmm",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:42): I'd make it as simple as possible for authors with copy &amp; paste samples",
        "f139aba52f9fa1394b4034a7954b2220 (12:42): why should a UA assume scoped variables and not invoking outside processes?",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:42): you could just define that if it returns anything but a non-empty string",
        "edb259c0e0038f38bb200bc20c8cbf7e (12:42): and that null and undefined count as the empty string",
        "f139aba52f9fa1394b4034a7954b2220 (12:45): I'll probably just change that to say this instead, since those other 2 assumptions don't make sense &quot;...user agents may assume that the object implementing the NSResolver interface (or ECMAScript Function) returns consistent results...&quot;",
        "f139aba52f9fa1394b4034a7954b2220 (12:51): hmm. No return value in JS means undefined, not void",
        "f139aba52f9fa1394b4034a7954b2220 (13:01): is there a need for the Interoperability Considerations section to be normative?  I can't see a reason for it, so I'll make it non-normative",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:07): as long as sections don't contain normative keywords you don't really have to mention it",
        "f139aba52f9fa1394b4034a7954b2220 (13:08): I rephrased it and it uses &quot;may&quot;, but not really in the RFC2119 sense, so I probably should explicitly state that",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:08): better to replace the use of may I suppose",
        "f139aba52f9fa1394b4034a7954b2220 (13:10): this is what it says now: &quot;Since user agents may optimise the algorithms described in this specification, and because some may invoke the NSResolver object more than others, interoperability concerns may arise if the the NSResolver object (or ECMAScript Function) causes side effects or returns inconsistent results each time it is invoked.&quot;",
        "f139aba52f9fa1394b4034a7954b2220 (13:11): any suggestions?",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:12): can arise",
        "edb259c0e0038f38bb200bc20c8cbf7e (13:12): are allowed to optimise",
        "f139aba52f9fa1394b4034a7954b2220 (13:13): that's like what was there before, and I didn't particularly like it"
    ],
    "person_ids": [
        "cc097e0d7183ae8436e7df709553c8c0",
        "edb259c0e0038f38bb200bc20c8cbf7e",
        "f139aba52f9fa1394b4034a7954b2220",
        "2d9b4b2e6d678d91f6afbf8a0763a223"
    ]
}